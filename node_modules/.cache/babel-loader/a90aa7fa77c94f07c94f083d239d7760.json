{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/**\n * minimal debounce function\n *\n * mostly for not spamming the server with requests when\n * searching with type ahead\n */\n\nfunction debounce(func, wait) {\n  var timeout;\n\n  var debouncedFn = function debouncedFn() {\n    var args = arguments;\n\n    var later = function later() {\n      func.apply(null, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n\n  debouncedFn.cancel = function () {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debouncedFn;\n}\n\nvar DebounceManager = /*#__PURE__*/function () {\n  function DebounceManager() {\n    _classCallCheck(this, DebounceManager);\n\n    _defineProperty(this, \"debounceCache\", {});\n  }\n\n  _createClass(DebounceManager, [{\n    key: \"runWithDebounce\",\n\n    /**\n     * Dynamically debounce and cache a debounced version of a function at the time of calling that function. This avoids\n     * managing debounced version of functions locally.\n     *\n     * In other words, debounce usually works by debouncing based on\n     * referential identity of a function. This works by comparing provided function names.\n     *\n     * This also has the ability to short-circuit a debounce all-together, if no wait\n     * time is provided.\n     *\n     * Assumption:\n     * Functions are debounced on a combination of unique function name and wait times. So debouncing won't work on\n     * subsequent calls with different wait times or different functions. That also means that the debounce manager\n     * can be used for different functions in parallel, and keep the two functions debounced separately.\n     *\n     * @param {number} wait Milliseconds to debounce. Executes immediately if falsey.\n     * @param {function} fn Function to debounce\n     * @param {function} functionName Name of function to debounce, used to create a unique key\n     * @param {...any} parameters Parameters to pass to function\n     */\n    value: function runWithDebounce(wait, functionName, fn) {\n      for (var _len = arguments.length, parameters = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        parameters[_key - 3] = arguments[_key];\n      }\n\n      if (!wait) {\n        return fn.apply(void 0, parameters);\n      }\n\n      var key = \"\".concat(functionName, \"|\").concat(wait.toString());\n      var debounced = this.debounceCache[key];\n\n      if (!debounced) {\n        this.debounceCache[key] = debounce(fn, wait);\n        debounced = this.debounceCache[key];\n      }\n\n      debounced.apply(void 0, parameters);\n    }\n    /**\n     * Cancels existing debounced function calls.\n     *\n     * This will cancel any debounced function call, regardless of the debounce length that was provided.\n     *\n     * For example, making the following series of calls will create multiple debounced functions, because\n     * they are cached by a combination of unique name and debounce length.\n     *\n     * runWithDebounce(1000, \"_updateSearchResults\", this._updateSearchResults)\n     * runWithDebounce(500, \"_updateSearchResults\", this._updateSearchResults)\n     * runWithDebounce(1000, \"_updateSearchResults\", this._updateSearchResults)\n     *\n     * Calling the following will cancel all of those, if they have not yet executed:\n     *\n     * cancelByName(\"_updateSearchResults\")\n     *\n     * @param {string} functionName The name of the function that was debounced. This needs to match exactly what was provided\n     * when runWithDebounce was called originally.\n     */\n\n  }, {\n    key: \"cancelByName\",\n    value: function cancelByName(functionName) {\n      Object.entries(this.debounceCache).filter(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            cachedKey = _ref2[0];\n\n        return cachedKey.startsWith(\"\".concat(functionName, \"|\"));\n      }) // eslint-disable-next-line no-unused-vars\n      .forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            _ = _ref4[0],\n            cachedValue = _ref4[1];\n\n        return cachedValue.cancel();\n      });\n    }\n  }]);\n\n  return DebounceManager;\n}();\n/**\n * Perform a standard debounce\n *\n * @param {number} wait Milliseconds to debounce. Executes immediately if falsey.\n * @param {function} fn Function to debounce\n */\n\n\nDebounceManager.debounce = function (wait, fn) {\n  return debounce(fn, wait);\n};\n\nexport default DebounceManager;","map":{"version":3,"sources":["../src/DebounceManager.js"],"names":["debouncedFn","args","later","func","clearTimeout","timeout","setTimeout","DebounceManager","wait","functionName","fn","parameters","key","debounced","debounce","Object","cachedKey","_","cachedValue"],"mappings":";;;;AAAA;;;;;;;AAMA,SAAA,QAAA,CAAA,IAAA,EAAA,IAAA,EAA8B;AAC5B,MAAA,OAAA;;AACA,MAAMA,WAAW,GAAG,SAAdA,WAAc,GAAW;AAC7B,QAAMC,IAAI,GAAV,SAAA;;AACA,QAAMC,KAAK,GAAG,SAARA,KAAQ,GAAM;AAClBC,MAAAA,IAAI,CAAJA,KAAAA,CAAAA,IAAAA,EAAAA,IAAAA;AADF,KAAA;;AAGAC,IAAAA,YAAY,CAAZA,OAAY,CAAZA;AACAC,IAAAA,OAAO,GAAGC,UAAU,CAAA,KAAA,EAApBD,IAAoB,CAApBA;AANF,GAAA;;AAQAL,EAAAA,WAAW,CAAXA,MAAAA,GAAqB,YAAM;AACzB,QAAA,OAAA,EAAa;AACXI,MAAAA,YAAY,CAAZA,OAAY,CAAZA;AACAC,MAAAA,OAAO,GAAPA,IAAAA;AACD;AAJHL,GAAAA;;AAMA,SAAA,WAAA;AACD;;IAEKO,e;;;;2CACY,E;;;;;;AAEhB;;;;;;;;;;;;;;;;;;;;oCAoBgBC,I,EAAMC,Y,EAAcC,E,EAAmB;AAAA,WAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAAZC,UAAY,GAAA,IAAA,KAAA,CAAA,IAAA,GAAA,CAAA,GAAA,IAAA,GAAA,CAAA,GAAA,CAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAAZA,QAAAA,UAAY,CAAA,IAAA,GAAA,CAAA,CAAZA,GAAY,SAAA,CAAA,IAAA,CAAZA;AAAY;;AACrD,UAAI,CAAJ,IAAA,EAAW;AACT,eAAOD,EAAE,CAAFA,KAAAA,CAAAA,KAAAA,CAAAA,EAAP,UAAOA,CAAP;AACD;;AAED,UAAME,GAAG,GAAA,GAAA,MAAA,CAAA,YAAA,EAAA,GAAA,EAAA,MAAA,CAAsBJ,IAAI,CAAnC,QAA+BA,EAAtB,CAAT;AACA,UAAIK,SAAS,GAAG,KAAA,aAAA,CAAhB,GAAgB,CAAhB;;AACA,UAAI,CAAJ,SAAA,EAAgB;AACd,aAAA,aAAA,CAAA,GAAA,IAA0BC,QAAQ,CAAA,EAAA,EAAlC,IAAkC,CAAlC;AACAD,QAAAA,SAAS,GAAG,KAAA,aAAA,CAAZA,GAAY,CAAZA;AACD;;AACDA,MAAAA,SAAS,CAATA,KAAAA,CAAAA,KAAAA,CAAAA,EAAAA,UAAAA;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;iCAmBaJ,Y,EAAc;AACzBM,MAAAA,MAAM,CAANA,OAAAA,CAAe,KAAfA,aAAAA,EAAAA,MAAAA,CACU,UAAA,IAAA,EAAA;AAAA,YAAA,KAAA,GAAA,cAAA,CAAA,IAAA,EAAA,CAAA,CAAA;AAAA,YAAEC,SAAF,GAAA,KAAA,CAAA,CAAA,CAAA;;AAAA,eAAiBA,SAAS,CAATA,UAAAA,CAAAA,GAAAA,MAAAA,CAAAA,YAAAA,EAAjB,GAAiBA,CAAAA,CAAjB;AADVD,OAAAA,EAEE;AAFFA,OAAAA,OAAAA,CAGW,UAAA,KAAA,EAAA;AAAA,YAAA,KAAA,GAAA,cAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,YAAEE,CAAF,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,YAAKC,WAAL,GAAA,KAAA,CAAA,CAAA,CAAA;;AAAA,eAAsBA,WAAW,CAAjC,MAAsBA,EAAtB;AAHXH,OAAAA;AAID;;;;;AAEH;;;;;;;;AAMAR,eAAe,CAAfA,QAAAA,GAA2B,UAAA,IAAA,EAAA,EAAA,EAAc;AACvC,SAAOO,QAAQ,CAAA,EAAA,EAAf,IAAe,CAAf;AADFP,CAAAA;;AAIA,eAAA,eAAA","sourcesContent":["/**\n * minimal debounce function\n *\n * mostly for not spamming the server with requests when\n * searching with type ahead\n */\nfunction debounce(func, wait) {\n  let timeout;\n  const debouncedFn = function() {\n    const args = arguments;\n    const later = () => {\n      func.apply(null, args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n  debouncedFn.cancel = () => {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  return debouncedFn;\n}\n\nclass DebounceManager {\n  debounceCache = {};\n\n  /**\n   * Dynamically debounce and cache a debounced version of a function at the time of calling that function. This avoids\n   * managing debounced version of functions locally.\n   *\n   * In other words, debounce usually works by debouncing based on\n   * referential identity of a function. This works by comparing provided function names.\n   *\n   * This also has the ability to short-circuit a debounce all-together, if no wait\n   * time is provided.\n   *\n   * Assumption:\n   * Functions are debounced on a combination of unique function name and wait times. So debouncing won't work on\n   * subsequent calls with different wait times or different functions. That also means that the debounce manager\n   * can be used for different functions in parallel, and keep the two functions debounced separately.\n   *\n   * @param {number} wait Milliseconds to debounce. Executes immediately if falsey.\n   * @param {function} fn Function to debounce\n   * @param {function} functionName Name of function to debounce, used to create a unique key\n   * @param {...any} parameters Parameters to pass to function\n   */\n  runWithDebounce(wait, functionName, fn, ...parameters) {\n    if (!wait) {\n      return fn(...parameters);\n    }\n\n    const key = `${functionName}|${wait.toString()}`;\n    let debounced = this.debounceCache[key];\n    if (!debounced) {\n      this.debounceCache[key] = debounce(fn, wait);\n      debounced = this.debounceCache[key];\n    }\n    debounced(...parameters);\n  }\n\n  /**\n   * Cancels existing debounced function calls.\n   *\n   * This will cancel any debounced function call, regardless of the debounce length that was provided.\n   *\n   * For example, making the following series of calls will create multiple debounced functions, because\n   * they are cached by a combination of unique name and debounce length.\n   *\n   * runWithDebounce(1000, \"_updateSearchResults\", this._updateSearchResults)\n   * runWithDebounce(500, \"_updateSearchResults\", this._updateSearchResults)\n   * runWithDebounce(1000, \"_updateSearchResults\", this._updateSearchResults)\n   *\n   * Calling the following will cancel all of those, if they have not yet executed:\n   *\n   * cancelByName(\"_updateSearchResults\")\n   *\n   * @param {string} functionName The name of the function that was debounced. This needs to match exactly what was provided\n   * when runWithDebounce was called originally.\n   */\n  cancelByName(functionName) {\n    Object.entries(this.debounceCache)\n      .filter(([cachedKey]) => cachedKey.startsWith(`${functionName}|`))\n      // eslint-disable-next-line no-unused-vars\n      .forEach(([_, cachedValue]) => cachedValue.cancel());\n  }\n}\n/**\n * Perform a standard debounce\n *\n * @param {number} wait Milliseconds to debounce. Executes immediately if falsey.\n * @param {function} fn Function to debounce\n */\nDebounceManager.debounce = (wait, fn) => {\n  return debounce(fn, wait);\n};\n\nexport default DebounceManager;\n"]},"metadata":{},"sourceType":"module"}