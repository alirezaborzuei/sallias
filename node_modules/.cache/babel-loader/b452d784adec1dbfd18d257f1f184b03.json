{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { createBrowserHistory as createHistory } from \"history\";\nimport queryString from \"./queryString\";\n\nfunction isNumericString(num) {\n  return !isNaN(num);\n}\n\nfunction toSingleValue(val) {\n  return Array.isArray(val) ? val[val.length - 1] : val;\n}\n\nfunction toSingleValueInteger(num) {\n  return toInteger(toSingleValue(num));\n}\n\nfunction toInteger(num) {\n  if (!isNumericString(num)) return;\n  return parseInt(num, 10);\n}\n\nfunction parseFiltersFromQueryParams(queryParams) {\n  return queryParams.filters;\n}\n\nfunction parseCurrentFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.current);\n}\n\nfunction parseSearchTermFromQueryParams(queryParams) {\n  return toSingleValue(queryParams.q);\n}\n\nfunction parseSortFromQueryParams(queryParams) {\n  var sortField = toSingleValue(queryParams[\"sort-field\"]);\n  var sortDirection = toSingleValue(queryParams[\"sort-direction\"]);\n  if (sortField) return [sortField, sortDirection];\n  return [];\n}\n\nfunction parseSizeFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.size);\n}\n\nfunction paramsToState(queryParams) {\n  var state = {\n    current: parseCurrentFromQueryParams(queryParams),\n    filters: parseFiltersFromQueryParams(queryParams),\n    searchTerm: parseSearchTermFromQueryParams(queryParams),\n    resultsPerPage: parseSizeFromQueryParams(queryParams),\n    sortField: parseSortFromQueryParams(queryParams)[0],\n    sortDirection: parseSortFromQueryParams(queryParams)[1]\n  };\n  return Object.keys(state).reduce(function (acc, key) {\n    var value = state[key];\n    if (value) acc[key] = value;\n    return acc;\n  }, {});\n}\n\nfunction stateToParams(_ref) {\n  var searchTerm = _ref.searchTerm,\n      current = _ref.current,\n      filters = _ref.filters,\n      resultsPerPage = _ref.resultsPerPage,\n      sortDirection = _ref.sortDirection,\n      sortField = _ref.sortField;\n  var params = {};\n  if (current > 1) params.current = current;\n  if (searchTerm) params.q = searchTerm;\n  if (resultsPerPage) params.size = resultsPerPage;\n\n  if (filters && filters.length > 0) {\n    params[\"filters\"] = filters;\n  }\n\n  if (sortField) {\n    params[\"sort-field\"] = sortField;\n    params[\"sort-direction\"] = sortDirection;\n  }\n\n  return params;\n}\n\nfunction stateToQueryString(state) {\n  return queryString.stringify(stateToParams(state));\n}\n/**\n * The URL Manager is responsible for synchronizing state between\n * SearchDriver and the URL. There are 3 main cases we handle when\n * synchronizing:\n *\n * 1. When the app loads, SearchDriver will need to\n * read the current state from the URL, in order to perform the search\n * expressed by the query string. `getStateFromURL` is used for this case.\n *\n * 2. When the URL changes as a result of `pushState` or `replaceState`,\n * SearchDriver will need to be notified and given the updated state, so that\n * it can re-run the current search. `onURLStateChange` is used for this case.\n *\n * 3. When state changes internally in the SearchDriver, as a result of an\n * Action, it will need to notify the URLManager of the change. `pushStateToURL`\n * is used for this case.\n */\n\n\nvar URLManager = /*#__PURE__*/function () {\n  function URLManager() {\n    _classCallCheck(this, URLManager);\n\n    this.history = createHistory();\n    this.lastPushSearchString = \"\";\n  }\n  /**\n   * Parse the current URL into application state\n   *\n   * @return {Object} - The parsed state object\n   */\n\n\n  _createClass(URLManager, [{\n    key: \"getStateFromURL\",\n    value: function getStateFromURL() {\n      return paramsToState(queryString.parse(this.history.location.search));\n    }\n    /**\n     * Push the current state of the application to the URL\n     *\n     * @param {Object} state - The entire current state from the SearchDriver\n     * @param {boolean} options\n     * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n     * rather than 'push' to avoid adding a new history entry\n     */\n\n  }, {\n    key: \"pushStateToURL\",\n    value: function pushStateToURL(state) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$replaceUrl = _ref2.replaceUrl,\n          replaceUrl = _ref2$replaceUrl === void 0 ? false : _ref2$replaceUrl;\n\n      var searchString = stateToQueryString(state);\n      this.lastPushSearchString = searchString;\n      var navigationFunction = replaceUrl ? this.history.replace : this.history.push;\n      navigationFunction({\n        search: \"?\".concat(searchString)\n      });\n    }\n    /**\n     * Add an event handler to be executed whenever state is pushed to the URL\n     *\n     * @callback requestCallback\n     * @param {Object} state - Updated application state parsed from the new URL\n     *\n     * @param {requestCallback} callback\n     */\n\n  }, {\n    key: \"onURLStateChange\",\n    value: function onURLStateChange(callback) {\n      var _this = this;\n\n      this.unlisten = this.history.listen(function (location) {\n        // If this URL is updated as a result of a pushState request, we don't\n        // want to notify that the URL changed.\n        if (\"?\".concat(_this.lastPushSearchString) === location.search) return; // Once we've decided to return based on lastPushSearchString, reset\n        // it so that we don't break back / forward button.\n\n        _this.lastPushSearchString = \"\";\n        callback(paramsToState(queryString.parse(location.search)));\n      });\n    }\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.unlisten();\n    }\n  }]);\n\n  return URLManager;\n}();\n\nexport { URLManager as default };","map":{"version":3,"sources":["../src/URLManager.js"],"names":["createBrowserHistory","isNaN","Array","val","toInteger","toSingleValue","isNumericString","parseInt","queryParams","toSingleValueInteger","sortField","sortDirection","state","current","parseCurrentFromQueryParams","filters","parseFiltersFromQueryParams","searchTerm","parseSearchTermFromQueryParams","resultsPerPage","parseSizeFromQueryParams","parseSortFromQueryParams","value","acc","params","queryString","stateToParams","URLManager","createHistory","paramsToState","replaceUrl","searchString","stateToQueryString","navigationFunction","search","callback","location"],"mappings":"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","sourcesContent":["import { createBrowserHistory as createHistory } from \"history\";\nimport queryString from \"./queryString\";\n\nfunction isNumericString(num) {\n  return !isNaN(num);\n}\n\nfunction toSingleValue(val) {\n  return Array.isArray(val) ? val[val.length - 1] : val;\n}\n\nfunction toSingleValueInteger(num) {\n  return toInteger(toSingleValue(num));\n}\n\nfunction toInteger(num) {\n  if (!isNumericString(num)) return;\n  return parseInt(num, 10);\n}\n\nfunction parseFiltersFromQueryParams(queryParams) {\n  return queryParams.filters;\n}\n\nfunction parseCurrentFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.current);\n}\n\nfunction parseSearchTermFromQueryParams(queryParams) {\n  return toSingleValue(queryParams.q);\n}\n\nfunction parseSortFromQueryParams(queryParams) {\n  const sortField = toSingleValue(queryParams[\"sort-field\"]);\n  const sortDirection = toSingleValue(queryParams[\"sort-direction\"]);\n\n  if (sortField) return [sortField, sortDirection];\n  return [];\n}\n\nfunction parseSizeFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.size);\n}\n\nfunction paramsToState(queryParams) {\n  const state = {\n    current: parseCurrentFromQueryParams(queryParams),\n    filters: parseFiltersFromQueryParams(queryParams),\n    searchTerm: parseSearchTermFromQueryParams(queryParams),\n    resultsPerPage: parseSizeFromQueryParams(queryParams),\n    sortField: parseSortFromQueryParams(queryParams)[0],\n    sortDirection: parseSortFromQueryParams(queryParams)[1]\n  };\n\n  return Object.keys(state).reduce((acc, key) => {\n    const value = state[key];\n    if (value) acc[key] = value;\n    return acc;\n  }, {});\n}\n\nfunction stateToParams({\n  searchTerm,\n  current,\n  filters,\n  resultsPerPage,\n  sortDirection,\n  sortField\n}) {\n  const params = {};\n\n  if (current > 1) params.current = current;\n  if (searchTerm) params.q = searchTerm;\n  if (resultsPerPage) params.size = resultsPerPage;\n  if (filters && filters.length > 0) {\n    params[\"filters\"] = filters;\n  }\n  if (sortField) {\n    params[\"sort-field\"] = sortField;\n    params[\"sort-direction\"] = sortDirection;\n  }\n\n  return params;\n}\n\nfunction stateToQueryString(state) {\n  return queryString.stringify(stateToParams(state));\n}\n\n/**\n * The URL Manager is responsible for synchronizing state between\n * SearchDriver and the URL. There are 3 main cases we handle when\n * synchronizing:\n *\n * 1. When the app loads, SearchDriver will need to\n * read the current state from the URL, in order to perform the search\n * expressed by the query string. `getStateFromURL` is used for this case.\n *\n * 2. When the URL changes as a result of `pushState` or `replaceState`,\n * SearchDriver will need to be notified and given the updated state, so that\n * it can re-run the current search. `onURLStateChange` is used for this case.\n *\n * 3. When state changes internally in the SearchDriver, as a result of an\n * Action, it will need to notify the URLManager of the change. `pushStateToURL`\n * is used for this case.\n */\n\nexport default class URLManager {\n  constructor() {\n    this.history = createHistory();\n    this.lastPushSearchString = \"\";\n  }\n\n  /**\n   * Parse the current URL into application state\n   *\n   * @return {Object} - The parsed state object\n   */\n  getStateFromURL() {\n    return paramsToState(queryString.parse(this.history.location.search));\n  }\n\n  /**\n   * Push the current state of the application to the URL\n   *\n   * @param {Object} state - The entire current state from the SearchDriver\n   * @param {boolean} options\n   * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n   * rather than 'push' to avoid adding a new history entry\n   */\n  pushStateToURL(state, { replaceUrl = false } = {}) {\n    const searchString = stateToQueryString(state);\n    this.lastPushSearchString = searchString;\n    const navigationFunction = replaceUrl\n      ? this.history.replace\n      : this.history.push;\n    navigationFunction({\n      search: `?${searchString}`\n    });\n  }\n\n  /**\n   * Add an event handler to be executed whenever state is pushed to the URL\n   *\n   * @callback requestCallback\n   * @param {Object} state - Updated application state parsed from the new URL\n   *\n   * @param {requestCallback} callback\n   */\n  onURLStateChange(callback) {\n    this.unlisten = this.history.listen(location => {\n      // If this URL is updated as a result of a pushState request, we don't\n      // want to notify that the URL changed.\n      if (`?${this.lastPushSearchString}` === location.search) return;\n\n      // Once we've decided to return based on lastPushSearchString, reset\n      // it so that we don't break back / forward button.\n      this.lastPushSearchString = \"\";\n\n      callback(paramsToState(queryString.parse(location.search)));\n    });\n  }\n\n  tearDown() {\n    this.unlisten();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}