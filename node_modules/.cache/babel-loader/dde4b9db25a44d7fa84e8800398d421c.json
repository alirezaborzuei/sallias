{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport * as ElasticAppSearch from \"@elastic/app-search-javascript\";\nimport { version } from \"../package.json\";\nimport { adaptResponse } from \"./responseAdapter\";\nimport { adaptRequest } from \"./requestAdapters\";\nimport buildResponseAdapterOptions from \"./buildResponseAdapterOptions\"; // The API will error out if empty facets or filters objects\n// are sent.\n\nfunction removeEmptyFacetsAndFilters(options) {\n  var facets = options.facets,\n      filters = options.filters,\n      rest = _objectWithoutProperties(options, [\"facets\", \"filters\"]);\n\n  return _objectSpread(_objectSpread(_objectSpread({}, facets && Object.entries(facets).length > 0 && {\n    facets: facets\n  }), filters && Object.entries(filters).length > 0 && {\n    filters: filters\n  }), rest);\n}\n\nvar AppSearchAPIConnector = /*#__PURE__*/function () {\n  /**\n   * @callback next\n   * @param {Object} updatedQueryOptions The options to send to the API\n   */\n\n  /**\n   * @callback hook\n   * @param {Object} queryOptions The options that are about to be sent to the API\n   * @param {next} next The options that are about to be sent to the API\n   */\n\n  /**\n   * @typedef Options\n   * @param {string} searchKey Credential found in your App Search Dashboard\n   * @param {string} engineName Engine to query, found in your App Search Dashboard\n   * @param {string} hostIdentifier Credential found in your App Search Dashboard\n   *  Useful when proxying the Swiftype API or developing against a local API server.\n   * @param {hook} beforeSearchCall=(queryOptions,next)=>next(queryOptions) A hook to amend query options before the request is sent to the\n   *   API in a query on an \"onSearch\" event.\n   * @param {hook} beforeAutocompleteResultsCall=(queryOptions,next)=>next(queryOptions) A hook to amend query options before the request is sent to the\n   *   API in a \"results\" query on an \"onAutocomplete\" event.\n   * @param {hook} beforeAutocompleteSuggestionsCall=(queryOptions,next)=>next(queryOptions) A hook to amend query options before the request is sent to\n   * the API in a \"suggestions\" query on an \"onAutocomplete\" event.\n   * @param {string} endpointBase=\"\" Overrides the base of the Swiftype API endpoint completely.\n   */\n\n  /**\n   * @param {Options} options\n   */\n  function AppSearchAPIConnector(_ref) {\n    var searchKey = _ref.searchKey,\n        engineName = _ref.engineName,\n        hostIdentifier = _ref.hostIdentifier,\n        _ref$beforeSearchCall = _ref.beforeSearchCall,\n        beforeSearchCall = _ref$beforeSearchCall === void 0 ? function (queryOptions, next) {\n      return next(queryOptions);\n    } : _ref$beforeSearchCall,\n        _ref$beforeAutocomple = _ref.beforeAutocompleteResultsCall,\n        beforeAutocompleteResultsCall = _ref$beforeAutocomple === void 0 ? function (queryOptions, next) {\n      return next(queryOptions);\n    } : _ref$beforeAutocomple,\n        _ref$beforeAutocomple2 = _ref.beforeAutocompleteSuggestionsCall,\n        beforeAutocompleteSuggestionsCall = _ref$beforeAutocomple2 === void 0 ? function (queryOptions, next) {\n      return next(queryOptions);\n    } : _ref$beforeAutocomple2,\n        _ref$endpointBase = _ref.endpointBase,\n        endpointBase = _ref$endpointBase === void 0 ? \"\" : _ref$endpointBase,\n        rest = _objectWithoutProperties(_ref, [\"searchKey\", \"engineName\", \"hostIdentifier\", \"beforeSearchCall\", \"beforeAutocompleteResultsCall\", \"beforeAutocompleteSuggestionsCall\", \"endpointBase\"]);\n\n    _classCallCheck(this, AppSearchAPIConnector);\n\n    if (!engineName || !(hostIdentifier || endpointBase) || !searchKey) {\n      throw Error(\"hostIdentifier or endpointBase, engineName, and searchKey are required\");\n    }\n\n    this.client = ElasticAppSearch.createClient(_objectSpread(_objectSpread(_objectSpread({}, endpointBase && {\n      endpointBase: endpointBase\n    }), hostIdentifier && {\n      hostIdentifier: hostIdentifier\n    }), {}, {\n      apiKey: searchKey,\n      engineName: engineName,\n      additionalHeaders: {\n        \"x-swiftype-integration\": \"search-ui\",\n        \"x-swiftype-integration-version\": version\n      }\n    }, rest));\n    this.beforeSearchCall = beforeSearchCall;\n    this.beforeAutocompleteResultsCall = beforeAutocompleteResultsCall;\n    this.beforeAutocompleteSuggestionsCall = beforeAutocompleteSuggestionsCall;\n  }\n\n  _createClass(AppSearchAPIConnector, [{\n    key: \"onResultClick\",\n    value: function onResultClick(_ref2) {\n      var query = _ref2.query,\n          documentId = _ref2.documentId,\n          requestId = _ref2.requestId,\n          _ref2$tags = _ref2.tags,\n          tags = _ref2$tags === void 0 ? [] : _ref2$tags;\n      tags = tags.concat(\"results\");\n      return this.client.click({\n        query: query,\n        documentId: documentId,\n        requestId: requestId,\n        tags: tags\n      });\n    }\n  }, {\n    key: \"onAutocompleteResultClick\",\n    value: function onAutocompleteResultClick(_ref3) {\n      var query = _ref3.query,\n          documentId = _ref3.documentId,\n          requestId = _ref3.requestId,\n          _ref3$tags = _ref3.tags,\n          tags = _ref3$tags === void 0 ? [] : _ref3$tags;\n      tags = tags.concat(\"autocomplete\");\n      return this.client.click({\n        query: query,\n        documentId: documentId,\n        requestId: requestId,\n        tags: tags\n      });\n    }\n  }, {\n    key: \"onSearch\",\n    value: function () {\n      var _onSearch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(state, queryConfig) {\n        var _this = this;\n\n        var current, filters, resultsPerPage, sortDirection, sortField, restOfQueryConfig, _adaptRequest, query, optionsFromState, withQueryConfigOptions, options;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                current = queryConfig.current, filters = queryConfig.filters, resultsPerPage = queryConfig.resultsPerPage, sortDirection = queryConfig.sortDirection, sortField = queryConfig.sortField, restOfQueryConfig = _objectWithoutProperties(queryConfig, [\"current\", \"filters\", \"resultsPerPage\", \"sortDirection\", \"sortField\"]);\n                _adaptRequest = adaptRequest(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, state), current !== undefined && {\n                  current: current\n                }), filters !== undefined && {\n                  filters: filters\n                }), resultsPerPage !== undefined && {\n                  resultsPerPage: resultsPerPage\n                }), sortDirection !== undefined && {\n                  sortDirection: sortDirection\n                }), sortField !== undefined && {\n                  sortField: sortField\n                })), query = _adaptRequest.query, optionsFromState = _objectWithoutProperties(_adaptRequest, [\"query\"]);\n                withQueryConfigOptions = _objectSpread(_objectSpread({}, restOfQueryConfig), optionsFromState);\n                options = _objectSpread({}, removeEmptyFacetsAndFilters(withQueryConfigOptions));\n                return _context2.abrupt(\"return\", this.beforeSearchCall(options, /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(newOptions) {\n                    var response;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return _this.client.search(query, newOptions);\n\n                          case 2:\n                            response = _context.sent;\n                            return _context.abrupt(\"return\", adaptResponse(response, buildResponseAdapterOptions(queryConfig)));\n\n                          case 4:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x3) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }()));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function onSearch(_x, _x2) {\n        return _onSearch.apply(this, arguments);\n      }\n\n      return onSearch;\n    }()\n  }, {\n    key: \"onAutocomplete\",\n    value: function () {\n      var _onAutocomplete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref5, queryConfig) {\n        var _this2 = this;\n\n        var searchTerm, autocompletedState, promises, _queryConfig$results, current, filters, resultsPerPage, sortDirection, sortField, restOfQueryConfig, _adaptRequest2, query, optionsFromState, withQueryConfigOptions, options, _options;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                searchTerm = _ref5.searchTerm;\n                autocompletedState = {};\n                promises = [];\n\n                if (queryConfig.results) {\n                  _queryConfig$results = queryConfig.results, current = _queryConfig$results.current, filters = _queryConfig$results.filters, resultsPerPage = _queryConfig$results.resultsPerPage, sortDirection = _queryConfig$results.sortDirection, sortField = _queryConfig$results.sortField, restOfQueryConfig = _objectWithoutProperties(_queryConfig$results, [\"current\", \"filters\", \"resultsPerPage\", \"sortDirection\", \"sortField\"]);\n                  _adaptRequest2 = adaptRequest({\n                    current: current,\n                    searchTerm: searchTerm,\n                    filters: filters,\n                    resultsPerPage: resultsPerPage,\n                    sortDirection: sortDirection,\n                    sortField: sortField\n                  }), query = _adaptRequest2.query, optionsFromState = _objectWithoutProperties(_adaptRequest2, [\"query\"]);\n                  withQueryConfigOptions = _objectSpread(_objectSpread({}, restOfQueryConfig), optionsFromState);\n                  options = removeEmptyFacetsAndFilters(withQueryConfigOptions);\n                  promises.push(this.beforeAutocompleteResultsCall(options, function (newOptions) {\n                    return _this2.client.search(query, newOptions).then(function (response) {\n                      autocompletedState.autocompletedResults = adaptResponse(response).results;\n                      autocompletedState.autocompletedResultsRequestId = response.info.meta.request_id;\n                    });\n                  }));\n                }\n\n                if (queryConfig.suggestions) {\n                  _options = queryConfig.suggestions;\n                  promises.push(this.beforeAutocompleteSuggestionsCall(_options, function (newOptions) {\n                    return _this2.client.querySuggestion(searchTerm, newOptions).then(function (response) {\n                      autocompletedState.autocompletedSuggestions = response.results;\n                      autocompletedState.autocompletedSuggestionsRequestId = response.meta.request_id;\n                    });\n                  }));\n                }\n\n                _context3.next = 7;\n                return Promise.all(promises);\n\n              case 7:\n                return _context3.abrupt(\"return\", autocompletedState);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function onAutocomplete(_x4, _x5) {\n        return _onAutocomplete.apply(this, arguments);\n      }\n\n      return onAutocomplete;\n    }()\n  }]);\n\n  return AppSearchAPIConnector;\n}();\n\nexport default AppSearchAPIConnector;","map":{"version":3,"sources":["../src/AppSearchAPIConnector.js"],"names":["facets","filters","rest","options","Object","AppSearchAPIConnector","searchKey","engineName","hostIdentifier","beforeSearchCall","next","beforeAutocompleteResultsCall","beforeAutocompleteSuggestionsCall","endpointBase","Error","apiKey","additionalHeaders","version","query","documentId","requestId","tags","state","queryConfig","current","resultsPerPage","sortDirection","sortField","restOfQueryConfig","optionsFromState","adaptRequest","withQueryConfigOptions","removeEmptyFacetsAndFilters","response","adaptResponse","buildResponseAdapterOptions","searchTerm","autocompletedState","promises","Promise"],"mappings":"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","sourcesContent":["import * as ElasticAppSearch from \"@elastic/app-search-javascript\";\nimport { version } from \"../package.json\";\n\nimport { adaptResponse } from \"./responseAdapter\";\nimport { adaptRequest } from \"./requestAdapters\";\nimport buildResponseAdapterOptions from \"./buildResponseAdapterOptions\";\n\n// The API will error out if empty facets or filters objects\n// are sent.\nfunction removeEmptyFacetsAndFilters(options) {\n  const { facets, filters, ...rest } = options;\n  return {\n    ...(facets && Object.entries(facets).length > 0 && { facets }),\n    ...(filters && Object.entries(filters).length > 0 && { filters }),\n    ...rest\n  };\n}\nclass AppSearchAPIConnector {\n  /**\n   * @callback next\n   * @param {Object} updatedQueryOptions The options to send to the API\n   */\n\n  /**\n   * @callback hook\n   * @param {Object} queryOptions The options that are about to be sent to the API\n   * @param {next} next The options that are about to be sent to the API\n   */\n\n  /**\n   * @typedef Options\n   * @param {string} searchKey Credential found in your App Search Dashboard\n   * @param {string} engineName Engine to query, found in your App Search Dashboard\n   * @param {string} hostIdentifier Credential found in your App Search Dashboard\n   *  Useful when proxying the Swiftype API or developing against a local API server.\n   * @param {hook} beforeSearchCall=(queryOptions,next)=>next(queryOptions) A hook to amend query options before the request is sent to the\n   *   API in a query on an \"onSearch\" event.\n   * @param {hook} beforeAutocompleteResultsCall=(queryOptions,next)=>next(queryOptions) A hook to amend query options before the request is sent to the\n   *   API in a \"results\" query on an \"onAutocomplete\" event.\n   * @param {hook} beforeAutocompleteSuggestionsCall=(queryOptions,next)=>next(queryOptions) A hook to amend query options before the request is sent to\n   * the API in a \"suggestions\" query on an \"onAutocomplete\" event.\n   * @param {string} endpointBase=\"\" Overrides the base of the Swiftype API endpoint completely.\n   */\n\n  /**\n   * @param {Options} options\n   */\n  constructor({\n    searchKey,\n    engineName,\n    hostIdentifier,\n    beforeSearchCall = (queryOptions, next) => next(queryOptions),\n    beforeAutocompleteResultsCall = (queryOptions, next) => next(queryOptions),\n    beforeAutocompleteSuggestionsCall = (queryOptions, next) =>\n      next(queryOptions),\n    endpointBase = \"\",\n    ...rest\n  }) {\n    if (!engineName || !(hostIdentifier || endpointBase) || !searchKey) {\n      throw Error(\n        \"hostIdentifier or endpointBase, engineName, and searchKey are required\"\n      );\n    }\n\n    this.client = ElasticAppSearch.createClient({\n      ...(endpointBase && { endpointBase }), //Add property on condition\n      ...(hostIdentifier && { hostIdentifier: hostIdentifier }),\n      apiKey: searchKey,\n      engineName: engineName,\n      additionalHeaders: {\n        \"x-swiftype-integration\": \"search-ui\",\n        \"x-swiftype-integration-version\": version\n      },\n      ...rest\n    });\n    this.beforeSearchCall = beforeSearchCall;\n    this.beforeAutocompleteResultsCall = beforeAutocompleteResultsCall;\n    this.beforeAutocompleteSuggestionsCall = beforeAutocompleteSuggestionsCall;\n  }\n\n  onResultClick({ query, documentId, requestId, tags = [] }) {\n    tags = tags.concat(\"results\");\n    return this.client.click({ query, documentId, requestId, tags });\n  }\n\n  onAutocompleteResultClick({ query, documentId, requestId, tags = [] }) {\n    tags = tags.concat(\"autocomplete\");\n    return this.client.click({ query, documentId, requestId, tags });\n  }\n\n  async onSearch(state, queryConfig) {\n    const {\n      current,\n      filters,\n      resultsPerPage,\n      sortDirection,\n      sortField,\n      ...restOfQueryConfig\n    } = queryConfig;\n\n    const { query, ...optionsFromState } = adaptRequest({\n      ...state,\n      ...(current !== undefined && { current }),\n      ...(filters !== undefined && { filters }),\n      ...(resultsPerPage !== undefined && { resultsPerPage }),\n      ...(sortDirection !== undefined && { sortDirection }),\n      ...(sortField !== undefined && { sortField })\n    });\n\n    const withQueryConfigOptions = {\n      ...restOfQueryConfig,\n      ...optionsFromState\n    };\n    const options = {\n      ...removeEmptyFacetsAndFilters(withQueryConfigOptions)\n    };\n\n    return this.beforeSearchCall(options, async newOptions => {\n      const response = await this.client.search(query, newOptions);\n      return adaptResponse(response, buildResponseAdapterOptions(queryConfig));\n    });\n  }\n\n  async onAutocomplete({ searchTerm }, queryConfig) {\n    const autocompletedState = {};\n    let promises = [];\n\n    if (queryConfig.results) {\n      const {\n        current,\n        filters,\n        resultsPerPage,\n        sortDirection,\n        sortField,\n        ...restOfQueryConfig\n      } = queryConfig.results;\n\n      const { query, ...optionsFromState } = adaptRequest({\n        current,\n        searchTerm,\n        filters,\n        resultsPerPage,\n        sortDirection,\n        sortField\n      });\n\n      const withQueryConfigOptions = {\n        ...restOfQueryConfig,\n        ...optionsFromState\n      };\n      const options = removeEmptyFacetsAndFilters(withQueryConfigOptions);\n      promises.push(\n        this.beforeAutocompleteResultsCall(options, newOptions => {\n          return this.client.search(query, newOptions).then(response => {\n            autocompletedState.autocompletedResults = adaptResponse(\n              response\n            ).results;\n            autocompletedState.autocompletedResultsRequestId =\n              response.info.meta.request_id;\n          });\n        })\n      );\n    }\n\n    if (queryConfig.suggestions) {\n      const options = queryConfig.suggestions;\n\n      promises.push(\n        this.beforeAutocompleteSuggestionsCall(options, newOptions =>\n          this.client.querySuggestion(searchTerm, newOptions).then(response => {\n            autocompletedState.autocompletedSuggestions = response.results;\n            autocompletedState.autocompletedSuggestionsRequestId =\n              response.meta.request_id;\n          })\n        )\n      );\n    }\n\n    await Promise.all(promises);\n    return autocompletedState;\n  }\n}\n\nexport default AppSearchAPIConnector;\n"]},"metadata":{},"sourceType":"module"}