{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport deepEqual from \"deep-equal\";\n/**\n * Given a list of applied Filters, find FilterValues based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {*} filters\n * @param {*} name\n * @param {*} filterType\n */\n\nexport function findFilterValues(filters, name, filterType) {\n  var filter = filters.find(function (f) {\n    return f.field === name && f.type === filterType;\n  });\n  if (!filter) return [];\n  return filter.values;\n}\n/**\n * Given a list of applied Filters, remove a single FilterValue based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {Filter[]} filters\n * @param {String} fieldName\n * @param {FilterValue} value\n * @param {FilterType} filterType\n */\n\nexport function removeSingleFilterValue(filters, fieldName, value, filterType) {\n  return filters.reduce(function (acc, filter) {\n    var field = filter.field,\n        values = filter.values,\n        type = filter.type,\n        rest = _objectWithoutProperties(filter, [\"field\", \"values\", \"type\"]);\n\n    if (field === fieldName && (!filterType || type === filterType)) {\n      var updatedFilterValues = values.filter(function (filterValue) {\n        return !doFilterValuesMatch(filterValue, value);\n      });\n\n      if (updatedFilterValues.length > 0) {\n        return acc.concat(_objectSpread({\n          field: field,\n          values: updatedFilterValues,\n          type: type\n        }, rest));\n      } else {\n        return acc;\n      }\n    }\n\n    return acc.concat(filter);\n  }, []);\n}\n/**\n * Given a Facet and a list of applied Filters, mark the Facet Values\n * for that Facet as \"selected\" based on \"fieldName\" and \"filterType\".\n *\n * @param {Facet} facet\n * @param {String} fieldName\n * @param {Filter[]} filters\n * @param {FilterType} filterType\n */\n\nexport function markSelectedFacetValuesFromFilters(facet, filters, fieldName, filterType) {\n  var facetValues = facet.data;\n  var filterValuesForField = findFilterValues(filters, fieldName, filterType) || [];\n  return _objectSpread(_objectSpread({}, facet), {}, {\n    data: facetValues.map(function (facetValue) {\n      return _objectSpread(_objectSpread({}, facetValue), {}, {\n        selected: filterValuesForField.some(function (filterValue) {\n          return doFilterValuesMatch(filterValue, facetValue.value);\n        })\n      });\n    })\n  });\n}\n/**\n * Useful for determining when filter values match. This could be used\n * when matching applied filters back to facet options, or for determining\n * whether or not a filter already exists in a list of applied filters.\n *\n * @param {FilterValue} filterValue1\n * @param {FilterValue} filterValue2\n */\n\nexport function doFilterValuesMatch(filterValue1, filterValue2) {\n  if (filterValue1 && filterValue1.name && filterValue2 && filterValue2.name && filterValue1.name === filterValue2.name) // If two filters have matching names, then they are the same filter, there\n    // is no need to do a more expensive deep equal comparison.\n    //\n    // This is also important because certain filters and facets will have\n    // differing values than their corresponding facet options. For instance,\n    // consider a time-based facet like \"Last 10 Minutes\". The value of the\n    // filter will be different depending on when it was selected, but the name\n    // will always match.\n    return true; // We use 'strict = true' to do a '===' of leaves, rather than '=='\n\n  return deepEqual(filterValue1, filterValue2, {\n    strict: true\n  });\n} // Mix unique filter type from one array into the other\n\nexport function mergeFilters(filters1, filters2) {\n  if (!filters2) return filters1;\n  return filters2.reduce(function (acc, next) {\n    if (acc.find(function (f) {\n      return f.type === next.type && f.field === next.field;\n    })) {\n      return acc;\n    }\n\n    return [].concat(_toConsumableArray(acc), [next]);\n  }, filters1);\n}","map":{"version":3,"sources":["../src/helpers.js"],"names":["filter","f","field","values","type","rest","updatedFilterValues","doFilterValuesMatch","acc","facetValues","facet","filterValuesForField","findFilterValues","data","selected","facetValue","filterValue1","filterValue2","deepEqual","strict","next"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAA,SAAA,MAAA,YAAA;AAEA;;;;;;;;;AAQA,OAAO,SAAA,gBAAA,CAAA,OAAA,EAAA,IAAA,EAAA,UAAA,EAAqD;AAC1D,MAAMA,MAAM,GAAG,OAAO,CAAP,IAAA,CAAa,UAAA,CAAA,EAAC;AAAA,WAAIC,CAAC,CAADA,KAAAA,KAAAA,IAAAA,IAAoBA,CAAC,CAADA,IAAAA,KAAxB,UAAA;AAA7B,GAAe,CAAf;AACA,MAAI,CAAJ,MAAA,EAAa,OAAA,EAAA;AACb,SAAOD,MAAM,CAAb,MAAA;AACD;AAED;;;;;;;;;;AASA,OAAO,SAAA,uBAAA,CAAA,OAAA,EAAA,SAAA,EAAA,KAAA,EAAA,UAAA,EAAwE;AAC7E,SAAO,OAAO,CAAP,MAAA,CAAe,UAAA,GAAA,EAAA,MAAA,EAAiB;AAAA,QAC7BE,KAD6B,GACIF,MADJ,CAAA,KAAA;AAAA,QACtBG,MADsB,GACIH,MADJ,CAAA,MAAA;AAAA,QACdI,IADc,GACIJ,MADJ,CAAA,IAAA;AAAA,QACLK,IADK,GAAA,wBAAA,CAAA,MAAA,EAAA,CAAA,OAAA,EAAA,QAAA,EAAA,MAAA,CAAA,CAAA;;AAErC,QAAIH,KAAK,KAALA,SAAAA,KAAwB,CAAA,UAAA,IAAeE,IAAI,KAA/C,UAAIF,CAAJ,EAAiE;AAC/D,UAAMI,mBAAmB,GAAG,MAAM,CAAN,MAAA,CAC1B,UAAA,WAAA,EAAW;AAAA,eAAI,CAACC,mBAAmB,CAAA,WAAA,EAAxB,KAAwB,CAAxB;AADb,OAA4B,CAA5B;;AAGA,UAAID,mBAAmB,CAAnBA,MAAAA,GAAJ,CAAA,EAAoC;AAClC,eAAO,GAAG,CAAH,MAAA,CAAA,aAAA,CAAA;AACLJ,UAAAA,KAAK,EADA,KAAA;AAELC,UAAAA,MAAM,EAFD,mBAAA;AAGLC,UAAAA,IAAI,EAAJA;AAHK,SAAA,EAAP,IAAO,CAAA,CAAP;AADF,OAAA,MAOO;AACL,eAAA,GAAA;AACD;AACF;;AACD,WAAOI,GAAG,CAAHA,MAAAA,CAAP,MAAOA,CAAP;AAjBK,GAAA,EAAP,EAAO,CAAP;AAmBD;AAED;;;;;;;;;;AASA,OAAO,SAAA,kCAAA,CAAA,KAAA,EAAA,OAAA,EAAA,SAAA,EAAA,UAAA,EAKL;AACA,MAAMC,WAAW,GAAGC,KAAK,CAAzB,IAAA;AACA,MAAMC,oBAAoB,GACxBC,gBAAgB,CAAA,OAAA,EAAA,SAAA,EAAhBA,UAAgB,CAAhBA,IADF,EAAA;AAEA,SAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,KAAA,CAAA,EAAA,EAAA,EAAA;AAEEC,IAAAA,IAAI,EAAE,WAAW,CAAX,GAAA,CAAgB,UAAA,UAAA,EAAc;AAClC,aAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,UAAA,CAAA,EAAA,EAAA,EAAA;AAEEC,QAAAA,QAAQ,EAAE,oBAAoB,CAApB,IAAA,CAA0B,UAAA,WAAA,EAAe;AACjD,iBAAOP,mBAAmB,CAAA,WAAA,EAAcQ,UAAU,CAAlD,KAA0B,CAA1B;AADQ,SAAA;AAFZ,OAAA,CAAA;AADI,KAAA;AAFR,GAAA,CAAA;AAWD;AAED;;;;;;;;;AAQA,OAAO,SAAA,mBAAA,CAAA,YAAA,EAAA,YAAA,EAAyD;AAC9D,MACEC,YAAY,IACZA,YAAY,CADZA,IAAAA,IAAAA,YAAAA,IAGAC,YAAY,CAHZD,IAAAA,IAIAA,YAAY,CAAZA,IAAAA,KAAsBC,YAAY,CALpC,IAAA,EAOE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAhB4D,IAgB5D,CAhB4D,CAiB9D;;AACA,SAAOC,SAAS,CAAA,YAAA,EAAA,YAAA,EAA6B;AAAEC,IAAAA,MAAM,EAAE;AAAV,GAA7B,CAAhB;EAGF;;AACA,OAAO,SAAA,YAAA,CAAA,QAAA,EAAA,QAAA,EAA0C;AAC/C,MAAI,CAAJ,QAAA,EAAe,OAAA,QAAA;AAEf,SAAO,QAAQ,CAAR,MAAA,CAAgB,UAAA,GAAA,EAAA,IAAA,EAAe;AACpC,QAAI,GAAG,CAAH,IAAA,CAAS,UAAA,CAAA,EAAC;AAAA,aAAIlB,CAAC,CAADA,IAAAA,KAAWmB,IAAI,CAAfnB,IAAAA,IAAwBA,CAAC,CAADA,KAAAA,KAAYmB,IAAI,CAA5C,KAAA;AAAd,KAAI,CAAJ,EAAmE;AACjE,aAAA,GAAA;AACD;;AACD,WAAA,GAAA,MAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,EAAA,CAAA,IAAA,CAAA,CAAA;AAJK,GAAA,EAAP,QAAO,CAAP;AAMD","sourcesContent":["import deepEqual from \"deep-equal\";\n\n/**\n * Given a list of applied Filters, find FilterValues based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {*} filters\n * @param {*} name\n * @param {*} filterType\n */\nexport function findFilterValues(filters, name, filterType) {\n  const filter = filters.find(f => f.field === name && f.type === filterType);\n  if (!filter) return [];\n  return filter.values;\n}\n\n/**\n * Given a list of applied Filters, remove a single FilterValue based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {Filter[]} filters\n * @param {String} fieldName\n * @param {FilterValue} value\n * @param {FilterType} filterType\n */\nexport function removeSingleFilterValue(filters, fieldName, value, filterType) {\n  return filters.reduce((acc, filter) => {\n    const { field, values, type, ...rest } = filter;\n    if (field === fieldName && (!filterType || type === filterType)) {\n      const updatedFilterValues = values.filter(\n        filterValue => !doFilterValuesMatch(filterValue, value)\n      );\n      if (updatedFilterValues.length > 0) {\n        return acc.concat({\n          field,\n          values: updatedFilterValues,\n          type,\n          ...rest\n        });\n      } else {\n        return acc;\n      }\n    }\n    return acc.concat(filter);\n  }, []);\n}\n\n/**\n * Given a Facet and a list of applied Filters, mark the Facet Values\n * for that Facet as \"selected\" based on \"fieldName\" and \"filterType\".\n *\n * @param {Facet} facet\n * @param {String} fieldName\n * @param {Filter[]} filters\n * @param {FilterType} filterType\n */\nexport function markSelectedFacetValuesFromFilters(\n  facet,\n  filters,\n  fieldName,\n  filterType\n) {\n  const facetValues = facet.data;\n  const filterValuesForField =\n    findFilterValues(filters, fieldName, filterType) || [];\n  return {\n    ...facet,\n    data: facetValues.map(facetValue => {\n      return {\n        ...facetValue,\n        selected: filterValuesForField.some(filterValue => {\n          return doFilterValuesMatch(filterValue, facetValue.value);\n        })\n      };\n    })\n  };\n}\n\n/**\n * Useful for determining when filter values match. This could be used\n * when matching applied filters back to facet options, or for determining\n * whether or not a filter already exists in a list of applied filters.\n *\n * @param {FilterValue} filterValue1\n * @param {FilterValue} filterValue2\n */\nexport function doFilterValuesMatch(filterValue1, filterValue2) {\n  if (\n    filterValue1 &&\n    filterValue1.name &&\n    filterValue2 &&\n    filterValue2.name &&\n    filterValue1.name === filterValue2.name\n  )\n    // If two filters have matching names, then they are the same filter, there\n    // is no need to do a more expensive deep equal comparison.\n    //\n    // This is also important because certain filters and facets will have\n    // differing values than their corresponding facet options. For instance,\n    // consider a time-based facet like \"Last 10 Minutes\". The value of the\n    // filter will be different depending on when it was selected, but the name\n    // will always match.\n    return true;\n  // We use 'strict = true' to do a '===' of leaves, rather than '=='\n  return deepEqual(filterValue1, filterValue2, { strict: true });\n}\n\n// Mix unique filter type from one array into the other\nexport function mergeFilters(filters1, filters2) {\n  if (!filters2) return filters1;\n\n  return filters2.reduce((acc, next) => {\n    if (acc.find(f => f.type === next.type && f.field === next.field)) {\n      return acc;\n    }\n    return [...acc, next];\n  }, filters1);\n}\n"]},"metadata":{},"sourceType":"module"}