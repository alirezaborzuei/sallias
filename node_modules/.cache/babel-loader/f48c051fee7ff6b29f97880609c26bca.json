{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport PropTypes from \"prop-types\";\nimport React, { useState, useEffect } from \"react\";\nimport { SearchDriver } from \"@elastic/search-ui\";\nimport SearchContext from \"./SearchContext\";\nimport defaultA11yMessages from \"./A11yNotifications\";\n/**\n * The SearchProvider primarily holds a reference to the SearchDriver and\n * exposes it to the rest of the application in a Context.\n */\n\nvar SearchProvider = function SearchProvider(_ref) {\n  var children = _ref.children,\n      _ref$config = _ref.config,\n      config = _ref$config === void 0 ? {} : _ref$config,\n      driver = _ref.driver;\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      driverInstance = _useState2[0],\n      setDriverInstance = _useState2[1];\n\n  useEffect(function () {\n    // This initialization is done inside of useEffect, because initializing the SearchDriver server side\n    // will error out, since the driver depends on window. Placing the initialization inside of useEffect\n    // assures that it won't attempt to initialize server side.\n    var currentDriver = driver || new SearchDriver(_objectSpread(_objectSpread({}, config), {}, {\n      a11yNotificationMessages: _objectSpread(_objectSpread({}, defaultA11yMessages), config.a11yNotificationMessages)\n    }));\n    setDriverInstance(currentDriver);\n    return function () {\n      currentDriver.tearDown();\n    };\n  }, []); // This effect allows users to dynamically update their searchQuery without re-mounting a SearchProvider,\n  // which would be destructive. An example of why this is useful is dynamically updating facets.\n\n  useEffect(function () {\n    if (driverInstance) {\n      driverInstance.setSearchQuery(config.searchQuery);\n    }\n  }, [config.searchQuery]);\n  useEffect(function () {\n    if (driverInstance) {\n      driverInstance.setAutocompleteQuery(config.autocompleteQuery);\n    }\n  }, [config.autocompleteQuery]); // Since driver is initialized in useEffect above, we are waiting\n  // to render until the driver is available.\n\n  if (!driverInstance) return null; // Passing the entire \"this.state\" to the Context is significant. Because\n  // Context determines when to re-render based on referential identity\n  // something like this could cause unnecessary renders:\n  //\n  // <SearchContext.Provider value={{driver: this.state.driver}}>\n  //\n  // By passing the entire state, we ensure that re-renders only occur when\n  // state is actually updated.\n\n  return /*#__PURE__*/React.createElement(SearchContext.Provider, {\n    value: {\n      driver: driverInstance\n    }\n  }, children);\n};\n\nSearchProvider.propTypes = {\n  children: PropTypes.node.isRequired,\n  // Not providing a shape here because the shape matches the shape of\n  // SearchDriver. SearchDriver can do it's own parameter validation.\n  config: PropTypes.object,\n  driver: PropTypes.object\n};\nexport default SearchProvider;","map":{"version":3,"sources":["../src/SearchProvider.js"],"names":["SearchProvider","children","config","driver","driverInstance","setDriverInstance","useState","useEffect","currentDriver","a11yNotificationMessages","PropTypes","object"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAA,SAAA,MAAA,YAAA;AACA,OAAA,KAAA,IAAA,QAAA,EAAA,SAAA,QAAA,OAAA;AAEA,SAAA,YAAA,QAAA,oBAAA;AACA,OAAA,aAAA,MAAA,iBAAA;AAEA,OAAA,mBAAA,MAAA,qBAAA;AAEA;;;;;AAIA,IAAMA,cAAc,GAAG,SAAjBA,cAAiB,CAAA,IAAA,EAAuC;AAAA,MAApCC,QAAoC,GAAA,IAAA,CAApCA,QAAoC;AAAA,MAAA,WAAA,GAAA,IAAA,CAA1BC,MAA0B;AAAA,MAA1BA,MAA0B,GAAA,WAAA,KAAA,KAAA,CAAA,GAAjB,EAAiB,GAAA,WAAA;AAAA,MAAbC,MAAa,GAAA,IAAA,CAAbA,MAAa;;AAAA,MAAA,SAAA,GAChBG,QAAQ,CADQ,IACR,CADQ;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAA,MACrDF,cADqD,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MACrCC,iBADqC,GAAA,UAAA,CAAA,CAAA,CAAA;;AAG5DE,EAAAA,SAAS,CAAC,YAAM;AACd;AACA;AACA;AACA,QAAMC,aAAa,GACjBL,MAAM,IACN,IAAA,YAAA,CAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,MAAA,CAAA,EAAA,EAAA,EAAA;AAEEM,MAAAA,wBAAwB,EAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,mBAAA,CAAA,EAEnBP,MAAM,CAFa,wBAAA;AAF1B,KAAA,CAAA,CAFF;AASAG,IAAAA,iBAAiB,CAAjBA,aAAiB,CAAjBA;AAEA,WAAO,YAAM;AACXG,MAAAA,aAAa,CAAbA,QAAAA;AADF,KAAA;AAfO,GAAA,EAHmD,EAGnD,CAATD,CAH4D,CAuB5D;AACA;;AACAA,EAAAA,SAAS,CAAC,YAAM;AACd,QAAA,cAAA,EAAoB;AAClBH,MAAAA,cAAc,CAAdA,cAAAA,CAA8BF,MAAM,CAApCE,WAAAA;AACD;AAHM,GAAA,EAIN,CAACF,MAAM,CAJVK,WAIG,CAJM,CAATA;AAMAA,EAAAA,SAAS,CAAC,YAAM;AACd,QAAA,cAAA,EAAoB;AAClBH,MAAAA,cAAc,CAAdA,oBAAAA,CAAoCF,MAAM,CAA1CE,iBAAAA;AACD;AAHM,GAAA,EAIN,CAACF,MAAM,CAnCkD,iBAmCzD,CAJM,CAATK,CA/B4D,CAqC5D;AACA;;AACA,MAAI,CAAJ,cAAA,EAAqB,OAvCuC,IAuCvC,CAvCuC,CAyC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAA,aACE,KAAA,CAAA,aAAA,CAAC,aAAD,CAAA,QAAA,EAAA;AAAwB,IAAA,KAAK,EAAE;AAAEJ,MAAAA,MAAM,EAAEC;AAAV;AAA/B,GAAA,EADF,QACE,CADF;AAjDF,CAAA;;AAwDAJ,cAAc,CAAdA,SAAAA,GAA2B;AACzBC,EAAAA,QAAQ,EAAES,SAAS,CAATA,IAAAA,CADe,UAAA;AAEzB;AACA;AACAR,EAAAA,MAAM,EAAEQ,SAAS,CAJQ,MAAA;AAKzBP,EAAAA,MAAM,EAAEO,SAAS,CAACC;AALO,CAA3BX;AAQA,eAAA,cAAA","sourcesContent":["import PropTypes from \"prop-types\";\nimport React, { useState, useEffect } from \"react\";\n\nimport { SearchDriver } from \"@elastic/search-ui\";\nimport SearchContext from \"./SearchContext\";\n\nimport defaultA11yMessages from \"./A11yNotifications\";\n\n/**\n * The SearchProvider primarily holds a reference to the SearchDriver and\n * exposes it to the rest of the application in a Context.\n */\nconst SearchProvider = ({ children, config = {}, driver }) => {\n  const [driverInstance, setDriverInstance] = useState(null);\n\n  useEffect(() => {\n    // This initialization is done inside of useEffect, because initializing the SearchDriver server side\n    // will error out, since the driver depends on window. Placing the initialization inside of useEffect\n    // assures that it won't attempt to initialize server side.\n    const currentDriver =\n      driver ||\n      new SearchDriver({\n        ...config,\n        a11yNotificationMessages: {\n          ...defaultA11yMessages,\n          ...config.a11yNotificationMessages\n        }\n      });\n    setDriverInstance(currentDriver);\n\n    return () => {\n      currentDriver.tearDown();\n    };\n  }, []);\n\n  // This effect allows users to dynamically update their searchQuery without re-mounting a SearchProvider,\n  // which would be destructive. An example of why this is useful is dynamically updating facets.\n  useEffect(() => {\n    if (driverInstance) {\n      driverInstance.setSearchQuery(config.searchQuery);\n    }\n  }, [config.searchQuery]);\n\n  useEffect(() => {\n    if (driverInstance) {\n      driverInstance.setAutocompleteQuery(config.autocompleteQuery);\n    }\n  }, [config.autocompleteQuery]);\n\n  // Since driver is initialized in useEffect above, we are waiting\n  // to render until the driver is available.\n  if (!driverInstance) return null;\n\n  // Passing the entire \"this.state\" to the Context is significant. Because\n  // Context determines when to re-render based on referential identity\n  // something like this could cause unnecessary renders:\n  //\n  // <SearchContext.Provider value={{driver: this.state.driver}}>\n  //\n  // By passing the entire state, we ensure that re-renders only occur when\n  // state is actually updated.\n  return (\n    <SearchContext.Provider value={{ driver: driverInstance }}>\n      {children}\n    </SearchContext.Provider>\n  );\n};\n\nSearchProvider.propTypes = {\n  children: PropTypes.node.isRequired,\n  // Not providing a shape here because the shape matches the shape of\n  // SearchDriver. SearchDriver can do it's own parameter validation.\n  config: PropTypes.object,\n  driver: PropTypes.object\n};\n\nexport default SearchProvider;\n"]},"metadata":{},"sourceType":"module"}