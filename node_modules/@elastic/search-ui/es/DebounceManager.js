import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

/**
 * minimal debounce function
 *
 * mostly for not spamming the server with requests when
 * searching with type ahead
 */
function debounce(func, wait) {
  var timeout;

  var debouncedFn = function debouncedFn() {
    var args = arguments;

    var later = function later() {
      func.apply(null, args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };

  debouncedFn.cancel = function () {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debouncedFn;
}

var DebounceManager = /*#__PURE__*/function () {
  function DebounceManager() {
    _classCallCheck(this, DebounceManager);

    _defineProperty(this, "debounceCache", {});
  }

  _createClass(DebounceManager, [{
    key: "runWithDebounce",

    /**
     * Dynamically debounce and cache a debounced version of a function at the time of calling that function. This avoids
     * managing debounced version of functions locally.
     *
     * In other words, debounce usually works by debouncing based on
     * referential identity of a function. This works by comparing provided function names.
     *
     * This also has the ability to short-circuit a debounce all-together, if no wait
     * time is provided.
     *
     * Assumption:
     * Functions are debounced on a combination of unique function name and wait times. So debouncing won't work on
     * subsequent calls with different wait times or different functions. That also means that the debounce manager
     * can be used for different functions in parallel, and keep the two functions debounced separately.
     *
     * @param {number} wait Milliseconds to debounce. Executes immediately if falsey.
     * @param {function} fn Function to debounce
     * @param {function} functionName Name of function to debounce, used to create a unique key
     * @param {...any} parameters Parameters to pass to function
     */
    value: function runWithDebounce(wait, functionName, fn) {
      for (var _len = arguments.length, parameters = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        parameters[_key - 3] = arguments[_key];
      }

      if (!wait) {
        return fn.apply(void 0, parameters);
      }

      var key = "".concat(functionName, "|").concat(wait.toString());
      var debounced = this.debounceCache[key];

      if (!debounced) {
        this.debounceCache[key] = debounce(fn, wait);
        debounced = this.debounceCache[key];
      }

      debounced.apply(void 0, parameters);
    }
    /**
     * Cancels existing debounced function calls.
     *
     * This will cancel any debounced function call, regardless of the debounce length that was provided.
     *
     * For example, making the following series of calls will create multiple debounced functions, because
     * they are cached by a combination of unique name and debounce length.
     *
     * runWithDebounce(1000, "_updateSearchResults", this._updateSearchResults)
     * runWithDebounce(500, "_updateSearchResults", this._updateSearchResults)
     * runWithDebounce(1000, "_updateSearchResults", this._updateSearchResults)
     *
     * Calling the following will cancel all of those, if they have not yet executed:
     *
     * cancelByName("_updateSearchResults")
     *
     * @param {string} functionName The name of the function that was debounced. This needs to match exactly what was provided
     * when runWithDebounce was called originally.
     */

  }, {
    key: "cancelByName",
    value: function cancelByName(functionName) {
      Object.entries(this.debounceCache).filter(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            cachedKey = _ref2[0];

        return cachedKey.startsWith("".concat(functionName, "|"));
      }) // eslint-disable-next-line no-unused-vars
      .forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            _ = _ref4[0],
            cachedValue = _ref4[1];

        return cachedValue.cancel();
      });
    }
  }]);

  return DebounceManager;
}();
/**
 * Perform a standard debounce
 *
 * @param {number} wait Milliseconds to debounce. Executes immediately if falsey.
 * @param {function} fn Function to debounce
 */


DebounceManager.debounce = function (wait, fn) {
  return debounce(fn, wait);
};

export default DebounceManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EZWJvdW5jZU1hbmFnZXIuanMiXSwibmFtZXMiOlsiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsInRpbWVvdXQiLCJkZWJvdW5jZWRGbiIsImFyZ3MiLCJhcmd1bWVudHMiLCJsYXRlciIsImFwcGx5IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNhbmNlbCIsIkRlYm91bmNlTWFuYWdlciIsImZ1bmN0aW9uTmFtZSIsImZuIiwicGFyYW1ldGVycyIsImtleSIsInRvU3RyaW5nIiwiZGVib3VuY2VkIiwiZGVib3VuY2VDYWNoZSIsIk9iamVjdCIsImVudHJpZXMiLCJmaWx0ZXIiLCJjYWNoZWRLZXkiLCJzdGFydHNXaXRoIiwiZm9yRWFjaCIsIl8iLCJjYWNoZWRWYWx1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7O0FBTUEsU0FBU0EsUUFBVCxDQUFrQkMsSUFBbEIsRUFBd0JDLElBQXhCLEVBQThCO0FBQzVCLE1BQUlDLE9BQUo7O0FBQ0EsTUFBTUMsV0FBVyxHQUFHLFNBQWRBLFdBQWMsR0FBVztBQUM3QixRQUFNQyxJQUFJLEdBQUdDLFNBQWI7O0FBQ0EsUUFBTUMsS0FBSyxHQUFHLFNBQVJBLEtBQVEsR0FBTTtBQUNsQk4sTUFBQUEsSUFBSSxDQUFDTyxLQUFMLENBQVcsSUFBWCxFQUFpQkgsSUFBakI7QUFDRCxLQUZEOztBQUdBSSxJQUFBQSxZQUFZLENBQUNOLE9BQUQsQ0FBWjtBQUNBQSxJQUFBQSxPQUFPLEdBQUdPLFVBQVUsQ0FBQ0gsS0FBRCxFQUFRTCxJQUFSLENBQXBCO0FBQ0QsR0FQRDs7QUFRQUUsRUFBQUEsV0FBVyxDQUFDTyxNQUFaLEdBQXFCLFlBQU07QUFDekIsUUFBSVIsT0FBSixFQUFhO0FBQ1hNLE1BQUFBLFlBQVksQ0FBQ04sT0FBRCxDQUFaO0FBQ0FBLE1BQUFBLE9BQU8sR0FBRyxJQUFWO0FBQ0Q7QUFDRixHQUxEOztBQU1BLFNBQU9DLFdBQVA7QUFDRDs7SUFFS1EsZTs7OzsyQ0FDWSxFOzs7Ozs7QUFFaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29DQW9CZ0JWLEksRUFBTVcsWSxFQUFjQyxFLEVBQW1CO0FBQUEsd0NBQVpDLFVBQVk7QUFBWkEsUUFBQUEsVUFBWTtBQUFBOztBQUNyRCxVQUFJLENBQUNiLElBQUwsRUFBVztBQUNULGVBQU9ZLEVBQUUsTUFBRixTQUFNQyxVQUFOLENBQVA7QUFDRDs7QUFFRCxVQUFNQyxHQUFHLGFBQU1ILFlBQU4sY0FBc0JYLElBQUksQ0FBQ2UsUUFBTCxFQUF0QixDQUFUO0FBQ0EsVUFBSUMsU0FBUyxHQUFHLEtBQUtDLGFBQUwsQ0FBbUJILEdBQW5CLENBQWhCOztBQUNBLFVBQUksQ0FBQ0UsU0FBTCxFQUFnQjtBQUNkLGFBQUtDLGFBQUwsQ0FBbUJILEdBQW5CLElBQTBCaEIsUUFBUSxDQUFDYyxFQUFELEVBQUtaLElBQUwsQ0FBbEM7QUFDQWdCLFFBQUFBLFNBQVMsR0FBRyxLQUFLQyxhQUFMLENBQW1CSCxHQUFuQixDQUFaO0FBQ0Q7O0FBQ0RFLE1BQUFBLFNBQVMsTUFBVCxTQUFhSCxVQUFiO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQ0FtQmFGLFksRUFBYztBQUN6Qk8sTUFBQUEsTUFBTSxDQUFDQyxPQUFQLENBQWUsS0FBS0YsYUFBcEIsRUFDR0csTUFESCxDQUNVO0FBQUE7QUFBQSxZQUFFQyxTQUFGOztBQUFBLGVBQWlCQSxTQUFTLENBQUNDLFVBQVYsV0FBd0JYLFlBQXhCLE9BQWpCO0FBQUEsT0FEVixFQUVFO0FBRkYsT0FHR1ksT0FISCxDQUdXO0FBQUE7QUFBQSxZQUFFQyxDQUFGO0FBQUEsWUFBS0MsV0FBTDs7QUFBQSxlQUFzQkEsV0FBVyxDQUFDaEIsTUFBWixFQUF0QjtBQUFBLE9BSFg7QUFJRDs7Ozs7QUFFSDs7Ozs7Ozs7QUFNQUMsZUFBZSxDQUFDWixRQUFoQixHQUEyQixVQUFDRSxJQUFELEVBQU9ZLEVBQVAsRUFBYztBQUN2QyxTQUFPZCxRQUFRLENBQUNjLEVBQUQsRUFBS1osSUFBTCxDQUFmO0FBQ0QsQ0FGRDs7QUFJQSxlQUFlVSxlQUFmIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtaW5pbWFsIGRlYm91bmNlIGZ1bmN0aW9uXG4gKlxuICogbW9zdGx5IGZvciBub3Qgc3BhbW1pbmcgdGhlIHNlcnZlciB3aXRoIHJlcXVlc3RzIHdoZW5cbiAqIHNlYXJjaGluZyB3aXRoIHR5cGUgYWhlYWRcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCkge1xuICBsZXQgdGltZW91dDtcbiAgY29uc3QgZGVib3VuY2VkRm4gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzO1xuICAgIGNvbnN0IGxhdGVyID0gKCkgPT4ge1xuICAgICAgZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9O1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gIH07XG4gIGRlYm91bmNlZEZuLmNhbmNlbCA9ICgpID0+IHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZGVib3VuY2VkRm47XG59XG5cbmNsYXNzIERlYm91bmNlTWFuYWdlciB7XG4gIGRlYm91bmNlQ2FjaGUgPSB7fTtcblxuICAvKipcbiAgICogRHluYW1pY2FsbHkgZGVib3VuY2UgYW5kIGNhY2hlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBmdW5jdGlvbiBhdCB0aGUgdGltZSBvZiBjYWxsaW5nIHRoYXQgZnVuY3Rpb24uIFRoaXMgYXZvaWRzXG4gICAqIG1hbmFnaW5nIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGZ1bmN0aW9ucyBsb2NhbGx5LlxuICAgKlxuICAgKiBJbiBvdGhlciB3b3JkcywgZGVib3VuY2UgdXN1YWxseSB3b3JrcyBieSBkZWJvdW5jaW5nIGJhc2VkIG9uXG4gICAqIHJlZmVyZW50aWFsIGlkZW50aXR5IG9mIGEgZnVuY3Rpb24uIFRoaXMgd29ya3MgYnkgY29tcGFyaW5nIHByb3ZpZGVkIGZ1bmN0aW9uIG5hbWVzLlxuICAgKlxuICAgKiBUaGlzIGFsc28gaGFzIHRoZSBhYmlsaXR5IHRvIHNob3J0LWNpcmN1aXQgYSBkZWJvdW5jZSBhbGwtdG9nZXRoZXIsIGlmIG5vIHdhaXRcbiAgICogdGltZSBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQXNzdW1wdGlvbjpcbiAgICogRnVuY3Rpb25zIGFyZSBkZWJvdW5jZWQgb24gYSBjb21iaW5hdGlvbiBvZiB1bmlxdWUgZnVuY3Rpb24gbmFtZSBhbmQgd2FpdCB0aW1lcy4gU28gZGVib3VuY2luZyB3b24ndCB3b3JrIG9uXG4gICAqIHN1YnNlcXVlbnQgY2FsbHMgd2l0aCBkaWZmZXJlbnQgd2FpdCB0aW1lcyBvciBkaWZmZXJlbnQgZnVuY3Rpb25zLiBUaGF0IGFsc28gbWVhbnMgdGhhdCB0aGUgZGVib3VuY2UgbWFuYWdlclxuICAgKiBjYW4gYmUgdXNlZCBmb3IgZGlmZmVyZW50IGZ1bmN0aW9ucyBpbiBwYXJhbGxlbCwgYW5kIGtlZXAgdGhlIHR3byBmdW5jdGlvbnMgZGVib3VuY2VkIHNlcGFyYXRlbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IE1pbGxpc2Vjb25kcyB0byBkZWJvdW5jZS4gRXhlY3V0ZXMgaW1tZWRpYXRlbHkgaWYgZmFsc2V5LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBkZWJvdW5jZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jdGlvbk5hbWUgTmFtZSBvZiBmdW5jdGlvbiB0byBkZWJvdW5jZSwgdXNlZCB0byBjcmVhdGUgYSB1bmlxdWUga2V5XG4gICAqIEBwYXJhbSB7Li4uYW55fSBwYXJhbWV0ZXJzIFBhcmFtZXRlcnMgdG8gcGFzcyB0byBmdW5jdGlvblxuICAgKi9cbiAgcnVuV2l0aERlYm91bmNlKHdhaXQsIGZ1bmN0aW9uTmFtZSwgZm4sIC4uLnBhcmFtZXRlcnMpIHtcbiAgICBpZiAoIXdhaXQpIHtcbiAgICAgIHJldHVybiBmbiguLi5wYXJhbWV0ZXJzKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBgJHtmdW5jdGlvbk5hbWV9fCR7d2FpdC50b1N0cmluZygpfWA7XG4gICAgbGV0IGRlYm91bmNlZCA9IHRoaXMuZGVib3VuY2VDYWNoZVtrZXldO1xuICAgIGlmICghZGVib3VuY2VkKSB7XG4gICAgICB0aGlzLmRlYm91bmNlQ2FjaGVba2V5XSA9IGRlYm91bmNlKGZuLCB3YWl0KTtcbiAgICAgIGRlYm91bmNlZCA9IHRoaXMuZGVib3VuY2VDYWNoZVtrZXldO1xuICAgIH1cbiAgICBkZWJvdW5jZWQoLi4ucGFyYW1ldGVycyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBleGlzdGluZyBkZWJvdW5jZWQgZnVuY3Rpb24gY2FsbHMuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBjYW5jZWwgYW55IGRlYm91bmNlZCBmdW5jdGlvbiBjYWxsLCByZWdhcmRsZXNzIG9mIHRoZSBkZWJvdW5jZSBsZW5ndGggdGhhdCB3YXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBtYWtpbmcgdGhlIGZvbGxvd2luZyBzZXJpZXMgb2YgY2FsbHMgd2lsbCBjcmVhdGUgbXVsdGlwbGUgZGVib3VuY2VkIGZ1bmN0aW9ucywgYmVjYXVzZVxuICAgKiB0aGV5IGFyZSBjYWNoZWQgYnkgYSBjb21iaW5hdGlvbiBvZiB1bmlxdWUgbmFtZSBhbmQgZGVib3VuY2UgbGVuZ3RoLlxuICAgKlxuICAgKiBydW5XaXRoRGVib3VuY2UoMTAwMCwgXCJfdXBkYXRlU2VhcmNoUmVzdWx0c1wiLCB0aGlzLl91cGRhdGVTZWFyY2hSZXN1bHRzKVxuICAgKiBydW5XaXRoRGVib3VuY2UoNTAwLCBcIl91cGRhdGVTZWFyY2hSZXN1bHRzXCIsIHRoaXMuX3VwZGF0ZVNlYXJjaFJlc3VsdHMpXG4gICAqIHJ1bldpdGhEZWJvdW5jZSgxMDAwLCBcIl91cGRhdGVTZWFyY2hSZXN1bHRzXCIsIHRoaXMuX3VwZGF0ZVNlYXJjaFJlc3VsdHMpXG4gICAqXG4gICAqIENhbGxpbmcgdGhlIGZvbGxvd2luZyB3aWxsIGNhbmNlbCBhbGwgb2YgdGhvc2UsIGlmIHRoZXkgaGF2ZSBub3QgeWV0IGV4ZWN1dGVkOlxuICAgKlxuICAgKiBjYW5jZWxCeU5hbWUoXCJfdXBkYXRlU2VhcmNoUmVzdWx0c1wiKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0aGF0IHdhcyBkZWJvdW5jZWQuIFRoaXMgbmVlZHMgdG8gbWF0Y2ggZXhhY3RseSB3aGF0IHdhcyBwcm92aWRlZFxuICAgKiB3aGVuIHJ1bldpdGhEZWJvdW5jZSB3YXMgY2FsbGVkIG9yaWdpbmFsbHkuXG4gICAqL1xuICBjYW5jZWxCeU5hbWUoZnVuY3Rpb25OYW1lKSB7XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5kZWJvdW5jZUNhY2hlKVxuICAgICAgLmZpbHRlcigoW2NhY2hlZEtleV0pID0+IGNhY2hlZEtleS5zdGFydHNXaXRoKGAke2Z1bmN0aW9uTmFtZX18YCkpXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIC5mb3JFYWNoKChbXywgY2FjaGVkVmFsdWVdKSA9PiBjYWNoZWRWYWx1ZS5jYW5jZWwoKSk7XG4gIH1cbn1cbi8qKlxuICogUGVyZm9ybSBhIHN0YW5kYXJkIGRlYm91bmNlXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgTWlsbGlzZWNvbmRzIHRvIGRlYm91bmNlLiBFeGVjdXRlcyBpbW1lZGlhdGVseSBpZiBmYWxzZXkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBkZWJvdW5jZVxuICovXG5EZWJvdW5jZU1hbmFnZXIuZGVib3VuY2UgPSAod2FpdCwgZm4pID0+IHtcbiAgcmV0dXJuIGRlYm91bmNlKGZuLCB3YWl0KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERlYm91bmNlTWFuYWdlcjtcbiJdfQ==