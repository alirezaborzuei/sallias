import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import { createBrowserHistory as createHistory } from "history";
import queryString from "./queryString";

function isNumericString(num) {
  return !isNaN(num);
}

function toSingleValue(val) {
  return Array.isArray(val) ? val[val.length - 1] : val;
}

function toSingleValueInteger(num) {
  return toInteger(toSingleValue(num));
}

function toInteger(num) {
  if (!isNumericString(num)) return;
  return parseInt(num, 10);
}

function parseFiltersFromQueryParams(queryParams) {
  return queryParams.filters;
}

function parseCurrentFromQueryParams(queryParams) {
  return toSingleValueInteger(queryParams.current);
}

function parseSearchTermFromQueryParams(queryParams) {
  return toSingleValue(queryParams.q);
}

function parseSortFromQueryParams(queryParams) {
  var sortField = toSingleValue(queryParams["sort-field"]);
  var sortDirection = toSingleValue(queryParams["sort-direction"]);
  if (sortField) return [sortField, sortDirection];
  return [];
}

function parseSizeFromQueryParams(queryParams) {
  return toSingleValueInteger(queryParams.size);
}

function paramsToState(queryParams) {
  var state = {
    current: parseCurrentFromQueryParams(queryParams),
    filters: parseFiltersFromQueryParams(queryParams),
    searchTerm: parseSearchTermFromQueryParams(queryParams),
    resultsPerPage: parseSizeFromQueryParams(queryParams),
    sortField: parseSortFromQueryParams(queryParams)[0],
    sortDirection: parseSortFromQueryParams(queryParams)[1]
  };
  return Object.keys(state).reduce(function (acc, key) {
    var value = state[key];
    if (value) acc[key] = value;
    return acc;
  }, {});
}

function stateToParams(_ref) {
  var searchTerm = _ref.searchTerm,
      current = _ref.current,
      filters = _ref.filters,
      resultsPerPage = _ref.resultsPerPage,
      sortDirection = _ref.sortDirection,
      sortField = _ref.sortField;
  var params = {};
  if (current > 1) params.current = current;
  if (searchTerm) params.q = searchTerm;
  if (resultsPerPage) params.size = resultsPerPage;

  if (filters && filters.length > 0) {
    params["filters"] = filters;
  }

  if (sortField) {
    params["sort-field"] = sortField;
    params["sort-direction"] = sortDirection;
  }

  return params;
}

function stateToQueryString(state) {
  return queryString.stringify(stateToParams(state));
}
/**
 * The URL Manager is responsible for synchronizing state between
 * SearchDriver and the URL. There are 3 main cases we handle when
 * synchronizing:
 *
 * 1. When the app loads, SearchDriver will need to
 * read the current state from the URL, in order to perform the search
 * expressed by the query string. `getStateFromURL` is used for this case.
 *
 * 2. When the URL changes as a result of `pushState` or `replaceState`,
 * SearchDriver will need to be notified and given the updated state, so that
 * it can re-run the current search. `onURLStateChange` is used for this case.
 *
 * 3. When state changes internally in the SearchDriver, as a result of an
 * Action, it will need to notify the URLManager of the change. `pushStateToURL`
 * is used for this case.
 */


var URLManager = /*#__PURE__*/function () {
  function URLManager() {
    _classCallCheck(this, URLManager);

    this.history = createHistory();
    this.lastPushSearchString = "";
  }
  /**
   * Parse the current URL into application state
   *
   * @return {Object} - The parsed state object
   */


  _createClass(URLManager, [{
    key: "getStateFromURL",
    value: function getStateFromURL() {
      return paramsToState(queryString.parse(this.history.location.search));
    }
    /**
     * Push the current state of the application to the URL
     *
     * @param {Object} state - The entire current state from the SearchDriver
     * @param {boolean} options
     * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'
     * rather than 'push' to avoid adding a new history entry
     */

  }, {
    key: "pushStateToURL",
    value: function pushStateToURL(state) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$replaceUrl = _ref2.replaceUrl,
          replaceUrl = _ref2$replaceUrl === void 0 ? false : _ref2$replaceUrl;

      var searchString = stateToQueryString(state);
      this.lastPushSearchString = searchString;
      var navigationFunction = replaceUrl ? this.history.replace : this.history.push;
      navigationFunction({
        search: "?".concat(searchString)
      });
    }
    /**
     * Add an event handler to be executed whenever state is pushed to the URL
     *
     * @callback requestCallback
     * @param {Object} state - Updated application state parsed from the new URL
     *
     * @param {requestCallback} callback
     */

  }, {
    key: "onURLStateChange",
    value: function onURLStateChange(callback) {
      var _this = this;

      this.unlisten = this.history.listen(function (location) {
        // If this URL is updated as a result of a pushState request, we don't
        // want to notify that the URL changed.
        if ("?".concat(_this.lastPushSearchString) === location.search) return; // Once we've decided to return based on lastPushSearchString, reset
        // it so that we don't break back / forward button.

        _this.lastPushSearchString = "";
        callback(paramsToState(queryString.parse(location.search)));
      });
    }
  }, {
    key: "tearDown",
    value: function tearDown() {
      this.unlisten();
    }
  }]);

  return URLManager;
}();

export { URLManager as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9VUkxNYW5hZ2VyLmpzIl0sIm5hbWVzIjpbImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiY3JlYXRlSGlzdG9yeSIsInF1ZXJ5U3RyaW5nIiwiaXNOdW1lcmljU3RyaW5nIiwibnVtIiwiaXNOYU4iLCJ0b1NpbmdsZVZhbHVlIiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwidG9TaW5nbGVWYWx1ZUludGVnZXIiLCJ0b0ludGVnZXIiLCJwYXJzZUludCIsInBhcnNlRmlsdGVyc0Zyb21RdWVyeVBhcmFtcyIsInF1ZXJ5UGFyYW1zIiwiZmlsdGVycyIsInBhcnNlQ3VycmVudEZyb21RdWVyeVBhcmFtcyIsImN1cnJlbnQiLCJwYXJzZVNlYXJjaFRlcm1Gcm9tUXVlcnlQYXJhbXMiLCJxIiwicGFyc2VTb3J0RnJvbVF1ZXJ5UGFyYW1zIiwic29ydEZpZWxkIiwic29ydERpcmVjdGlvbiIsInBhcnNlU2l6ZUZyb21RdWVyeVBhcmFtcyIsInNpemUiLCJwYXJhbXNUb1N0YXRlIiwic3RhdGUiLCJzZWFyY2hUZXJtIiwicmVzdWx0c1BlclBhZ2UiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwia2V5IiwidmFsdWUiLCJzdGF0ZVRvUGFyYW1zIiwicGFyYW1zIiwic3RhdGVUb1F1ZXJ5U3RyaW5nIiwic3RyaW5naWZ5IiwiVVJMTWFuYWdlciIsImhpc3RvcnkiLCJsYXN0UHVzaFNlYXJjaFN0cmluZyIsInBhcnNlIiwibG9jYXRpb24iLCJzZWFyY2giLCJyZXBsYWNlVXJsIiwic2VhcmNoU3RyaW5nIiwibmF2aWdhdGlvbkZ1bmN0aW9uIiwicmVwbGFjZSIsInB1c2giLCJjYWxsYmFjayIsInVubGlzdGVuIiwibGlzdGVuIl0sIm1hcHBpbmdzIjoiOztBQUFBLFNBQVNBLG9CQUFvQixJQUFJQyxhQUFqQyxRQUFzRCxTQUF0RDtBQUNBLE9BQU9DLFdBQVAsTUFBd0IsZUFBeEI7O0FBRUEsU0FBU0MsZUFBVCxDQUF5QkMsR0FBekIs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LENBQXZDO0FBQ0EsV0FBS2Usb0JBQUwsR0FBNEJLLFlBQTVCO0FBQ0EsVUFBTUMsa0JBQWtCLEdBQUdGLFVBQVUsR0FDakMsS0FBS0wsT0FBTCxDQUFhUSxPQURvQixHQUVqQyxLQUFLUixPQUFMLENBQWFTLElBRmpCO0FBR0FGLE1BQUFBLGtCQUFrQixDQUFDO0FBQ2pCSCxRQUFBQSxNQUFNLGFBQU1FLFlBQU47QUFEVyxPQUFELENBQWxCO0FBR0Q7QUFFRDs7Ozs7Ozs7Ozs7cUNBUWlCSSxRLEVBQVU7QUFBQTs7QUFDekIsV0FBS0MsUUFBTCxHQUFnQixLQUFLWCxPQUFMLENBQWFZLE1BQWIsQ0FBb0IsVUFBQVQsUUFBUSxFQUFJO0FBQzlDO0FBQ0E7QUFDQSxZQUFJLFdBQUksS0FBSSxDQUFDRixvQkFBVCxNQUFvQ0UsUUFBUSxDQUFDQyxNQUFqRCxFQUF5RCxPQUhYLENBSzlDO0FBQ0E7O0FBQ0EsUUFBQSxLQUFJLENBQUNILG9CQUFMLEdBQTRCLEVBQTVCO0FBRUFTLFFBQUFBLFFBQVEsQ0FBQ3pCLGFBQWEsQ0FBQ3hCLFdBQVcsQ0FBQ3lDLEtBQVosQ0FBa0JDLFFBQVEsQ0FBQ0MsTUFBM0IsQ0FBRCxDQUFkLENBQVI7QUFDRCxPQVZlLENBQWhCO0FBV0Q7OzsrQkFFVTtBQUNULFdBQUtPLFFBQUw7QUFDRDs7Ozs7O1NBMURrQlosVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5IGFzIGNyZWF0ZUhpc3RvcnkgfSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IHF1ZXJ5U3RyaW5nIGZyb20gXCIuL3F1ZXJ5U3RyaW5nXCI7XG5cbmZ1bmN0aW9uIGlzTnVtZXJpY1N0cmluZyhudW0pIHtcbiAgcmV0dXJuICFpc05hTihudW0pO1xufVxuXG5mdW5jdGlvbiB0b1NpbmdsZVZhbHVlKHZhbCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsW3ZhbC5sZW5ndGggLSAxXSA6IHZhbDtcbn1cblxuZnVuY3Rpb24gdG9TaW5nbGVWYWx1ZUludGVnZXIobnVtKSB7XG4gIHJldHVybiB0b0ludGVnZXIodG9TaW5nbGVWYWx1ZShudW0pKTtcbn1cblxuZnVuY3Rpb24gdG9JbnRlZ2VyKG51bSkge1xuICBpZiAoIWlzTnVtZXJpY1N0cmluZyhudW0pKSByZXR1cm47XG4gIHJldHVybiBwYXJzZUludChudW0sIDEwKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzRnJvbVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSB7XG4gIHJldHVybiBxdWVyeVBhcmFtcy5maWx0ZXJzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUN1cnJlbnRGcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpIHtcbiAgcmV0dXJuIHRvU2luZ2xlVmFsdWVJbnRlZ2VyKHF1ZXJ5UGFyYW1zLmN1cnJlbnQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlYXJjaFRlcm1Gcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpIHtcbiAgcmV0dXJuIHRvU2luZ2xlVmFsdWUocXVlcnlQYXJhbXMucSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU29ydEZyb21RdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykge1xuICBjb25zdCBzb3J0RmllbGQgPSB0b1NpbmdsZVZhbHVlKHF1ZXJ5UGFyYW1zW1wic29ydC1maWVsZFwiXSk7XG4gIGNvbnN0IHNvcnREaXJlY3Rpb24gPSB0b1NpbmdsZVZhbHVlKHF1ZXJ5UGFyYW1zW1wic29ydC1kaXJlY3Rpb25cIl0pO1xuXG4gIGlmIChzb3J0RmllbGQpIHJldHVybiBbc29ydEZpZWxkLCBzb3J0RGlyZWN0aW9uXTtcbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNpemVGcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpIHtcbiAgcmV0dXJuIHRvU2luZ2xlVmFsdWVJbnRlZ2VyKHF1ZXJ5UGFyYW1zLnNpemUpO1xufVxuXG5mdW5jdGlvbiBwYXJhbXNUb1N0YXRlKHF1ZXJ5UGFyYW1zKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGN1cnJlbnQ6IHBhcnNlQ3VycmVudEZyb21RdWVyeVBhcmFtcyhxdWVyeVBhcmFtcyksXG4gICAgZmlsdGVyczogcGFyc2VGaWx0ZXJzRnJvbVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSxcbiAgICBzZWFyY2hUZXJtOiBwYXJzZVNlYXJjaFRlcm1Gcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpLFxuICAgIHJlc3VsdHNQZXJQYWdlOiBwYXJzZVNpemVGcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpLFxuICAgIHNvcnRGaWVsZDogcGFyc2VTb3J0RnJvbVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKVswXSxcbiAgICBzb3J0RGlyZWN0aW9uOiBwYXJzZVNvcnRGcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpWzFdXG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGF0ZVtrZXldO1xuICAgIGlmICh2YWx1ZSkgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlVG9QYXJhbXMoe1xuICBzZWFyY2hUZXJtLFxuICBjdXJyZW50LFxuICBmaWx0ZXJzLFxuICByZXN1bHRzUGVyUGFnZSxcbiAgc29ydERpcmVjdGlvbixcbiAgc29ydEZpZWxkXG59KSB7XG4gIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gIGlmIChjdXJyZW50ID4gMSkgcGFyYW1zLmN1cnJlbnQgPSBjdXJyZW50O1xuICBpZiAoc2VhcmNoVGVybSkgcGFyYW1zLnEgPSBzZWFyY2hUZXJtO1xuICBpZiAocmVzdWx0c1BlclBhZ2UpIHBhcmFtcy5zaXplID0gcmVzdWx0c1BlclBhZ2U7XG4gIGlmIChmaWx0ZXJzICYmIGZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgIHBhcmFtc1tcImZpbHRlcnNcIl0gPSBmaWx0ZXJzO1xuICB9XG4gIGlmIChzb3J0RmllbGQpIHtcbiAgICBwYXJhbXNbXCJzb3J0LWZpZWxkXCJdID0gc29ydEZpZWxkO1xuICAgIHBhcmFtc1tcInNvcnQtZGlyZWN0aW9uXCJdID0gc29ydERpcmVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIHN0YXRlVG9RdWVyeVN0cmluZyhzdGF0ZSkge1xuICByZXR1cm4gcXVlcnlTdHJpbmcuc3RyaW5naWZ5KHN0YXRlVG9QYXJhbXMoc3RhdGUpKTtcbn1cblxuLyoqXG4gKiBUaGUgVVJMIE1hbmFnZXIgaXMgcmVzcG9uc2libGUgZm9yIHN5bmNocm9uaXppbmcgc3RhdGUgYmV0d2VlblxuICogU2VhcmNoRHJpdmVyIGFuZCB0aGUgVVJMLiBUaGVyZSBhcmUgMyBtYWluIGNhc2VzIHdlIGhhbmRsZSB3aGVuXG4gKiBzeW5jaHJvbml6aW5nOlxuICpcbiAqIDEuIFdoZW4gdGhlIGFwcCBsb2FkcywgU2VhcmNoRHJpdmVyIHdpbGwgbmVlZCB0b1xuICogcmVhZCB0aGUgY3VycmVudCBzdGF0ZSBmcm9tIHRoZSBVUkwsIGluIG9yZGVyIHRvIHBlcmZvcm0gdGhlIHNlYXJjaFxuICogZXhwcmVzc2VkIGJ5IHRoZSBxdWVyeSBzdHJpbmcuIGBnZXRTdGF0ZUZyb21VUkxgIGlzIHVzZWQgZm9yIHRoaXMgY2FzZS5cbiAqXG4gKiAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlcyBhcyBhIHJlc3VsdCBvZiBgcHVzaFN0YXRlYCBvciBgcmVwbGFjZVN0YXRlYCxcbiAqIFNlYXJjaERyaXZlciB3aWxsIG5lZWQgdG8gYmUgbm90aWZpZWQgYW5kIGdpdmVuIHRoZSB1cGRhdGVkIHN0YXRlLCBzbyB0aGF0XG4gKiBpdCBjYW4gcmUtcnVuIHRoZSBjdXJyZW50IHNlYXJjaC4gYG9uVVJMU3RhdGVDaGFuZ2VgIGlzIHVzZWQgZm9yIHRoaXMgY2FzZS5cbiAqXG4gKiAzLiBXaGVuIHN0YXRlIGNoYW5nZXMgaW50ZXJuYWxseSBpbiB0aGUgU2VhcmNoRHJpdmVyLCBhcyBhIHJlc3VsdCBvZiBhblxuICogQWN0aW9uLCBpdCB3aWxsIG5lZWQgdG8gbm90aWZ5IHRoZSBVUkxNYW5hZ2VyIG9mIHRoZSBjaGFuZ2UuIGBwdXNoU3RhdGVUb1VSTGBcbiAqIGlzIHVzZWQgZm9yIHRoaXMgY2FzZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVUkxNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeSgpO1xuICAgIHRoaXMubGFzdFB1c2hTZWFyY2hTdHJpbmcgPSBcIlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBjdXJyZW50IFVSTCBpbnRvIGFwcGxpY2F0aW9uIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgcGFyc2VkIHN0YXRlIG9iamVjdFxuICAgKi9cbiAgZ2V0U3RhdGVGcm9tVVJMKCkge1xuICAgIHJldHVybiBwYXJhbXNUb1N0YXRlKHF1ZXJ5U3RyaW5nLnBhcnNlKHRoaXMuaGlzdG9yeS5sb2NhdGlvbi5zZWFyY2gpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBhcHBsaWNhdGlvbiB0byB0aGUgVVJMXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIFRoZSBlbnRpcmUgY3VycmVudCBzdGF0ZSBmcm9tIHRoZSBTZWFyY2hEcml2ZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5yZXBsYWNlVXJsIC0gV2hlbiBwdXNoaW5nIHN0YXRlIHRvIHRoZSBVUkwsIHVzZSBoaXN0b3J5ICdyZXBsYWNlJ1xuICAgKiByYXRoZXIgdGhhbiAncHVzaCcgdG8gYXZvaWQgYWRkaW5nIGEgbmV3IGhpc3RvcnkgZW50cnlcbiAgICovXG4gIHB1c2hTdGF0ZVRvVVJMKHN0YXRlLCB7IHJlcGxhY2VVcmwgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCBzZWFyY2hTdHJpbmcgPSBzdGF0ZVRvUXVlcnlTdHJpbmcoc3RhdGUpO1xuICAgIHRoaXMubGFzdFB1c2hTZWFyY2hTdHJpbmcgPSBzZWFyY2hTdHJpbmc7XG4gICAgY29uc3QgbmF2aWdhdGlvbkZ1bmN0aW9uID0gcmVwbGFjZVVybFxuICAgICAgPyB0aGlzLmhpc3RvcnkucmVwbGFjZVxuICAgICAgOiB0aGlzLmhpc3RvcnkucHVzaDtcbiAgICBuYXZpZ2F0aW9uRnVuY3Rpb24oe1xuICAgICAgc2VhcmNoOiBgPyR7c2VhcmNoU3RyaW5nfWBcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgaGFuZGxlciB0byBiZSBleGVjdXRlZCB3aGVuZXZlciBzdGF0ZSBpcyBwdXNoZWQgdG8gdGhlIFVSTFxuICAgKlxuICAgKiBAY2FsbGJhY2sgcmVxdWVzdENhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIFVwZGF0ZWQgYXBwbGljYXRpb24gc3RhdGUgcGFyc2VkIGZyb20gdGhlIG5ldyBVUkxcbiAgICpcbiAgICogQHBhcmFtIHtyZXF1ZXN0Q2FsbGJhY2t9IGNhbGxiYWNrXG4gICAqL1xuICBvblVSTFN0YXRlQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51bmxpc3RlbiA9IHRoaXMuaGlzdG9yeS5saXN0ZW4obG9jYXRpb24gPT4ge1xuICAgICAgLy8gSWYgdGhpcyBVUkwgaXMgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZiBhIHB1c2hTdGF0ZSByZXF1ZXN0LCB3ZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBub3RpZnkgdGhhdCB0aGUgVVJMIGNoYW5nZWQuXG4gICAgICBpZiAoYD8ke3RoaXMubGFzdFB1c2hTZWFyY2hTdHJpbmd9YCA9PT0gbG9jYXRpb24uc2VhcmNoKSByZXR1cm47XG5cbiAgICAgIC8vIE9uY2Ugd2UndmUgZGVjaWRlZCB0byByZXR1cm4gYmFzZWQgb24gbGFzdFB1c2hTZWFyY2hTdHJpbmcsIHJlc2V0XG4gICAgICAvLyBpdCBzbyB0aGF0IHdlIGRvbid0IGJyZWFrIGJhY2sgLyBmb3J3YXJkIGJ1dHRvbi5cbiAgICAgIHRoaXMubGFzdFB1c2hTZWFyY2hTdHJpbmcgPSBcIlwiO1xuXG4gICAgICBjYWxsYmFjayhwYXJhbXNUb1N0YXRlKHF1ZXJ5U3RyaW5nLnBhcnNlKGxvY2F0aW9uLnNlYXJjaCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRlYXJEb3duKCkge1xuICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgfVxufVxuIl19