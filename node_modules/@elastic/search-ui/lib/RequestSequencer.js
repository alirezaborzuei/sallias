"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

/*
  This deals with sequencing of our async requests. When a lot of requests are firing very close to one another
  and are running in parallel, what happens if they return out of order? It creates a race condition.

  For example, if I type the term "react" in the search box, two queries may be initiated, in parallel.

  1. query for "reac"
  2. query for "react"

  If the query for "react" actually returns **before** the query for "reac",
  we could end up looking at the results for "reac", despite having typed "react" in the search box.

  To deal with this, we keep track of a sequence.
  */
var RequestSequencer = /*#__PURE__*/function () {
  function RequestSequencer() {
    (0, _classCallCheck2.default)(this, RequestSequencer);
    (0, _defineProperty2.default)(this, "requestSequence", 0);
    (0, _defineProperty2.default)(this, "lastCompleted", 0);
  }

  (0, _createClass2.default)(RequestSequencer, [{
    key: "next",
    value: function next() {
      return ++this.requestSequence;
    }
  }, {
    key: "isOldRequest",
    value: function isOldRequest(request) {
      return request < this.lastCompleted;
    }
  }, {
    key: "completed",
    value: function completed(request) {
      this.lastCompleted = request;
    }
  }]);
  return RequestSequencer;
}();

exports.default = RequestSequencer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZXF1ZXN0U2VxdWVuY2VyLmpzIl0sIm5hbWVzIjpbIlJlcXVlc3RTZXF1ZW5jZXIiLCJyZXF1ZXN0U2VxdWVuY2UiLCJyZXF1ZXN0IiwibGFzdENvbXBsZXRlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7O0lBY3FCQSxnQjs7OzJEQUNELEM7eURBQ0YsQzs7Ozs7MkJBRVQ7QUFDTCxhQUFPLEVBQUUsS0FBS0MsZUFBZDtBQUNEOzs7aUNBRVlDLE8sRUFBUztBQUNwQixhQUFPQSxPQUFPLEdBQUcsS0FBS0MsYUFBdEI7QUFDRDs7OzhCQUVTRCxPLEVBQVM7QUFDakIsV0FBS0MsYUFBTCxHQUFxQkQsT0FBckI7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIFRoaXMgZGVhbHMgd2l0aCBzZXF1ZW5jaW5nIG9mIG91ciBhc3luYyByZXF1ZXN0cy4gV2hlbiBhIGxvdCBvZiByZXF1ZXN0cyBhcmUgZmlyaW5nIHZlcnkgY2xvc2UgdG8gb25lIGFub3RoZXJcbiAgYW5kIGFyZSBydW5uaW5nIGluIHBhcmFsbGVsLCB3aGF0IGhhcHBlbnMgaWYgdGhleSByZXR1cm4gb3V0IG9mIG9yZGVyPyBJdCBjcmVhdGVzIGEgcmFjZSBjb25kaXRpb24uXG5cbiAgRm9yIGV4YW1wbGUsIGlmIEkgdHlwZSB0aGUgdGVybSBcInJlYWN0XCIgaW4gdGhlIHNlYXJjaCBib3gsIHR3byBxdWVyaWVzIG1heSBiZSBpbml0aWF0ZWQsIGluIHBhcmFsbGVsLlxuXG4gIDEuIHF1ZXJ5IGZvciBcInJlYWNcIlxuICAyLiBxdWVyeSBmb3IgXCJyZWFjdFwiXG5cbiAgSWYgdGhlIHF1ZXJ5IGZvciBcInJlYWN0XCIgYWN0dWFsbHkgcmV0dXJucyAqKmJlZm9yZSoqIHRoZSBxdWVyeSBmb3IgXCJyZWFjXCIsXG4gIHdlIGNvdWxkIGVuZCB1cCBsb29raW5nIGF0IHRoZSByZXN1bHRzIGZvciBcInJlYWNcIiwgZGVzcGl0ZSBoYXZpbmcgdHlwZWQgXCJyZWFjdFwiIGluIHRoZSBzZWFyY2ggYm94LlxuXG4gIFRvIGRlYWwgd2l0aCB0aGlzLCB3ZSBrZWVwIHRyYWNrIG9mIGEgc2VxdWVuY2UuXG4gICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXF1ZXN0U2VxdWVuY2VyIHtcbiAgcmVxdWVzdFNlcXVlbmNlID0gMDtcbiAgbGFzdENvbXBsZXRlZCA9IDA7XG5cbiAgbmV4dCgpIHtcbiAgICByZXR1cm4gKyt0aGlzLnJlcXVlc3RTZXF1ZW5jZTtcbiAgfVxuXG4gIGlzT2xkUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3QgPCB0aGlzLmxhc3RDb21wbGV0ZWQ7XG4gIH1cblxuICBjb21wbGV0ZWQocmVxdWVzdCkge1xuICAgIHRoaXMubGFzdENvbXBsZXRlZCA9IHJlcXVlc3Q7XG4gIH1cbn1cbiJdfQ==